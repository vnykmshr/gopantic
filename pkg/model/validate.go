package model

import (
	"math"
	"reflect"
	"strconv"
	"strings"
	"sync"
)

// Validator represents a validation rule that can be applied to a field.
// Implement this interface to create custom validators for specific validation logic.
type Validator interface {
	// Validate checks if the value is valid according to this validator's rules
	Validate(fieldName string, value interface{}) error
	// Name returns the name of this validator (e.g., "required", "min", "email")
	Name() string
}

// ValidationRule represents a single validation rule parsed from struct tags.
// Contains the validator instance and any parameters specified in the tag.
type ValidationRule struct {
	Name       string                 // Name of the validator (e.g., "min")
	Validator  Validator              // The validator instance
	Parameters map[string]interface{} // Parameters for the validator (e.g., {"value": 5})
}

// FieldValidation contains all validation rules for a single struct field.
// Used internally to organize validation rules by field during parsing.
type FieldValidation struct {
	FieldName string           // Name of the struct field
	JSONKey   string           // JSON key for this field
	Rules     []ValidationRule // List of validation rules to apply
}

// StructValidation contains validation information for an entire struct.
// Generated by ParseValidationTags and used during the validation phase.
type StructValidation struct {
	Fields []FieldValidation // Validation rules for each field
}

// ValidatorFunc represents a custom validation function for field-level validation.
// Use RegisterGlobalFunc to register custom validators that can be used in struct tags.
type ValidatorFunc func(fieldName string, value interface{}, params map[string]interface{}) error

// CrossFieldValidatorFunc represents a validation function that has access to the entire struct.
// Use RegisterGlobalCrossFieldFunc for validators that need to access other fields for validation.
type CrossFieldValidatorFunc func(fieldName string, fieldValue interface{}, structValue reflect.Value, params map[string]interface{}) error

// ValidatorRegistry manages the collection of available validators.
// Provides registration and lookup capabilities for built-in and custom validators.
type ValidatorRegistry struct {
	validators      map[string]func(params map[string]interface{}) Validator
	customFuncs     map[string]ValidatorFunc
	crossFieldFuncs map[string]CrossFieldValidatorFunc
}

// NewValidatorRegistry creates a new validator registry with built-in validators.
// Includes required, min, max, email, length, alpha, and alphanum validators.
func NewValidatorRegistry() *ValidatorRegistry {
	registry := &ValidatorRegistry{
		validators:      make(map[string]func(params map[string]interface{}) Validator),
		customFuncs:     make(map[string]ValidatorFunc),
		crossFieldFuncs: make(map[string]CrossFieldValidatorFunc),
	}

	// Register built-in validators
	registry.Register("required", func(params map[string]interface{}) Validator {
		return &RequiredValidator{}
	})

	registry.Register("min", func(params map[string]interface{}) Validator {
		if val, ok := params["value"]; ok {
			if minVal, err := toFloat64(val); err == nil {
				return &MinValidator{Min: minVal}
			}
		}
		return &MinValidator{Min: 0} // Default minimum
	})

	registry.Register("max", func(params map[string]interface{}) Validator {
		if val, ok := params["value"]; ok {
			if maxVal, err := toFloat64(val); err == nil {
				return &MaxValidator{Max: maxVal}
			}
		}
		return &MaxValidator{Max: 0} // Default maximum
	})

	registry.Register("email", func(params map[string]interface{}) Validator {
		return &EmailValidator{}
	})

	registry.Register("length", func(params map[string]interface{}) Validator {
		if val, ok := params["value"]; ok {
			if lengthVal, err := toInt(val); err == nil {
				return &LengthValidator{Length: lengthVal}
			}
		}
		return &LengthValidator{Length: 0} // Default length
	})

	registry.Register("alpha", func(params map[string]interface{}) Validator {
		return &AlphaValidator{}
	})

	registry.Register("alphanum", func(params map[string]interface{}) Validator {
		return &AlphanumValidator{}
	})

	return registry
}

// Register adds a new validator to the registry
func (r *ValidatorRegistry) Register(name string, factory func(params map[string]interface{}) Validator) {
	r.validators[name] = factory
}

// RegisterFunc adds a custom validation function to the registry.
// Custom functions provide a simpler API for common validation cases.
//
// Example usage:
//
//	registry := model.GetDefaultRegistry()
//	registry.RegisterFunc("contains", func(fieldName string, value interface{}, params map[string]interface{}) error {
//	    str, ok := value.(string)
//	    if !ok {
//	        return fmt.Errorf("value must be a string")
//	    }
//
//	    substring, ok := params["value"].(string)
//	    if !ok {
//	        return fmt.Errorf("contains validator requires a string parameter")
//	    }
//
//	    if !strings.Contains(str, substring) {
//	        return model.NewValidationError(fieldName, value, "contains",
//	            fmt.Sprintf("value must contain '%s'", substring))
//	    }
//	    return nil
//	})
func (r *ValidatorRegistry) RegisterFunc(name string, validatorFunc ValidatorFunc) {
	r.customFuncs[name] = validatorFunc
}

// RegisterCrossFieldFunc adds a cross-field validation function to the registry.
// Cross-field validators have access to the entire struct and can validate relationships between fields.
//
// Example usage:
//
//	registry.RegisterCrossFieldFunc("password_match", func(fieldName string, fieldValue interface{}, structValue reflect.Value, params map[string]interface{}) error {
//	    password := structValue.FieldByName("Password").Interface().(string)
//	    confirmPassword, ok := fieldValue.(string)
//	    if !ok {
//	        return model.NewValidationError(fieldName, fieldValue, "password_match", "value must be a string")
//	    }
//
//	    if password != confirmPassword {
//	        return model.NewValidationError(fieldName, fieldValue, "password_match", "passwords do not match")
//	    }
//
//	    return nil
//	})
func (r *ValidatorRegistry) RegisterCrossFieldFunc(name string, validatorFunc CrossFieldValidatorFunc) {
	r.crossFieldFuncs[name] = validatorFunc
}

// CustomFuncValidator wraps a ValidatorFunc to implement the Validator interface
type CustomFuncValidator struct {
	name   string
	fn     ValidatorFunc
	params map[string]interface{}
}

// Name returns the name of the custom validator
func (v *CustomFuncValidator) Name() string {
	return v.name
}

// Validate executes the custom validation function
func (v *CustomFuncValidator) Validate(fieldName string, value interface{}) error {
	return v.fn(fieldName, value, v.params)
}

// CrossFieldValidator wraps a CrossFieldValidatorFunc to implement special validation interface
type CrossFieldValidator struct {
	name   string
	fn     CrossFieldValidatorFunc
	params map[string]interface{}
}

// Name returns the name of the cross-field validator
func (v *CrossFieldValidator) Name() string {
	return v.name
}

// Validate returns an error as cross-field validators require full struct context
func (v *CrossFieldValidator) Validate(fieldName string, value interface{}) error {
	// This should not be called directly - cross-field validation requires the full struct
	return NewValidationError(fieldName, value, v.name, "cross-field validator requires full struct context")
}

// ValidateWithStruct performs cross-field validation with access to the full struct
func (v *CrossFieldValidator) ValidateWithStruct(fieldName string, fieldValue interface{}, structValue reflect.Value) error {
	return v.fn(fieldName, fieldValue, structValue, v.params)
}

// Create creates a validator instance from the registry
func (r *ValidatorRegistry) Create(name string, params map[string]interface{}) Validator {
	// Check cross-field functions first
	if crossFieldFunc, exists := r.crossFieldFuncs[name]; exists {
		return &CrossFieldValidator{
			name:   name,
			fn:     crossFieldFunc,
			params: params,
		}
	}

	// Check custom functions next
	if customFunc, exists := r.customFuncs[name]; exists {
		return &CustomFuncValidator{
			name:   name,
			fn:     customFunc,
			params: params,
		}
	}

	// Fall back to built-in validators
	if factory, exists := r.validators[name]; exists {
		return factory(params)
	}

	return nil // Unknown validator
}

// Global validator registry instance
var defaultRegistry = NewValidatorRegistry()

// Global cache for validation metadata by type
var validationCache sync.Map

// MaxCacheSize is the maximum number of struct types to cache validation metadata for.
// When the cache size exceeds this limit, the oldest entries are removed (FIFO).
// Set to 0 for unlimited caching (not recommended for long-running services).
// Default: 1000 types.
//
// WARNING: Direct modification of this variable is NOT thread-safe.
// For concurrent access, use GetMaxCacheSize() and SetMaxCacheSize().
var MaxCacheSize = 1000

// MaxValidationDepth is the maximum depth of nested struct validation.
// This prevents stack overflow and DoS attacks from deeply nested structures.
// Default: 32 levels.
//
// WARNING: Direct modification of this variable is NOT thread-safe.
// For concurrent access, use GetMaxValidationDepth() and SetMaxValidationDepth().
var MaxValidationDepth = 32

var (
	cacheOrder      []reflect.Type
	cacheOrderMutex sync.Mutex
)

// GetDefaultRegistry returns the default global validator registry.
// This registry contains all built-in validators and any custom validators
// registered via RegisterGlobalFunc and RegisterGlobalCrossFieldFunc.
func GetDefaultRegistry() *ValidatorRegistry {
	return defaultRegistry
}

// RegisterGlobalFunc is a convenience function to register a custom validation function
// to the default global registry.
//
// Note: If you register custom validators after types have been parsed, you should call
// ClearValidationCache() to ensure new validators are used for all subsequent parses.
//
// Example usage:
//
//	model.RegisterGlobalFunc("password_strength", func(fieldName string, value interface{}, params map[string]interface{}) error {
//	    password, ok := value.(string)
//	    if !ok || password == "" {
//	        return nil // handled by required validator
//	    }
//
//	    if len(password) < 8 {
//	        return model.NewValidationError(fieldName, value, "password_strength", "password must be at least 8 characters")
//	    }
//
//	    hasUpper := strings.ContainsAny(password, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
//	    hasLower := strings.ContainsAny(password, "abcdefghijklmnopqrstuvwxyz")
//	    hasDigit := strings.ContainsAny(password, "0123456789")
//
//	    if !hasUpper || !hasLower || !hasDigit {
//	        return model.NewValidationError(fieldName, value, "password_strength", "password must contain uppercase, lowercase, and numeric characters")
//	    }
//
//	    return nil
//	})
func RegisterGlobalFunc(name string, validatorFunc ValidatorFunc) {
	defaultRegistry.RegisterFunc(name, validatorFunc)
}

// RegisterGlobalCrossFieldFunc is a convenience function to register a cross-field validation function
// to the default global registry.
//
// Note: If you register custom validators after types have been parsed, you should call
// ClearValidationCache() to ensure new validators are used for all subsequent parses.
//
// Example usage:
//
//	model.RegisterGlobalCrossFieldFunc("password_match", func(fieldName string, fieldValue interface{}, structValue reflect.Value, params map[string]interface{}) error {
//	    passwordField := structValue.FieldByName("Password")
//	    if !passwordField.IsValid() {
//	        return model.NewValidationError(fieldName, fieldValue, "password_match", "Password field not found")
//	    }
//
//	    password := passwordField.Interface().(string)
//	    confirmPassword, ok := fieldValue.(string)
//	    if !ok {
//	        return model.NewValidationError(fieldName, fieldValue, "password_match", "value must be a string")
//	    }
//
//	    if password != confirmPassword {
//	        return model.NewValidationError(fieldName, fieldValue, "password_match", "passwords do not match")
//	    }
//
//	    return nil
//	})
func RegisterGlobalCrossFieldFunc(name string, validatorFunc CrossFieldValidatorFunc) {
	defaultRegistry.RegisterCrossFieldFunc(name, validatorFunc)
}

// ClearValidationCache clears the cached validation metadata for all types.
// This is useful when you register new custom validators and want to ensure
// they are applied to types that have already been parsed.
// In normal operation, you should not need to call this function.
func ClearValidationCache() {
	validationCache.Range(func(key, value interface{}) bool {
		validationCache.Delete(key)
		return true
	})

	// Clear cache order tracking
	cacheOrderMutex.Lock()
	cacheOrder = nil
	cacheOrderMutex.Unlock()
}

// ListValidators returns a list of all registered validator names (built-in, custom, and cross-field)
func (r *ValidatorRegistry) ListValidators() []string {
	names := make([]string, 0, len(r.validators)+len(r.customFuncs)+len(r.crossFieldFuncs))

	// Add built-in validators
	for name := range r.validators {
		names = append(names, name)
	}

	// Add custom function validators
	for name := range r.customFuncs {
		names = append(names, name)
	}

	// Add cross-field validators
	for name := range r.crossFieldFuncs {
		names = append(names, name)
	}

	return names
}

// ParseValidationTags parses validation tags from a struct and returns validation info.
// This function analyzes struct tags and builds the validation rules for efficient validation.
// The returned StructValidation is automatically cached by type for performance.
// Subsequent calls with the same type will return the cached result.
func ParseValidationTags(structType reflect.Type) *StructValidation {
	// Check cache first
	if cached, ok := validationCache.Load(structType); ok {
		return cached.(*StructValidation)
	}

	// Parse validation tags
	validation := parseValidationTagsUncached(structType)

	// Store in cache with size limit enforcement
	storeInValidationCache(structType, validation)

	return validation
}

// storeInValidationCache stores validation metadata in the cache with size limit enforcement.
func storeInValidationCache(structType reflect.Type, validation *StructValidation) {
	maxCacheSize := GetMaxCacheSize()
	if maxCacheSize == 0 {
		// Unlimited caching
		validationCache.Store(structType, validation)
		return
	}

	cacheOrderMutex.Lock()
	defer cacheOrderMutex.Unlock()

	// Check if cache is full
	if len(cacheOrder) >= maxCacheSize {
		// Remove oldest entry (FIFO)
		oldest := cacheOrder[0]
		validationCache.Delete(oldest)
		cacheOrder = cacheOrder[1:]
	}

	// Add new entry
	validationCache.Store(structType, validation)
	cacheOrder = append(cacheOrder, structType)
}

// parseValidationTagsUncached performs the actual parsing without caching
func parseValidationTagsUncached(structType reflect.Type) *StructValidation {
	validation := &StructValidation{
		Fields: make([]FieldValidation, 0),
	}

	for i := 0; i < structType.NumField(); i++ {
		field := structType.Field(i)

		// Skip unexported fields
		if !field.IsExported() {
			continue
		}

		// Get validation tag
		validateTag := field.Tag.Get("validate")
		if validateTag == "" || validateTag == "-" {
			continue // No validation rules for this field
		}

		// Parse JSON key
		jsonKey := getFieldKey(field, FormatJSON)
		if jsonKey == "-" {
			continue // Field is excluded from JSON
		}

		// Parse validation rules
		rules, err := parseValidationRules(validateTag)
		if err != nil {
			// Skip field with invalid validation syntax
			continue
		}

		if len(rules) > 0 {
			fieldValidation := FieldValidation{
				FieldName: field.Name,
				JSONKey:   jsonKey,
				Rules:     rules,
			}
			validation.Fields = append(validation.Fields, fieldValidation)
		}
	}

	return validation
}

// parseValidationRules parses a validation tag string into ValidationRule structs
// Example: "required,min=5,max=100,email" -> []ValidationRule
func parseValidationRules(tag string) ([]ValidationRule, error) {
	rules := make([]ValidationRule, 0)
	registry := GetDefaultRegistry()

	// Split by comma to get individual rules
	ruleParts := strings.Split(tag, ",")

	for _, part := range ruleParts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		// Parse rule name and parameters
		// Format: "min=5" or "required" or "range=1:10"
		var ruleName string
		params := make(map[string]interface{})

		if equalPos := strings.Index(part, "="); equalPos > 0 {
			// Rule with parameter: "min=5"
			ruleName = part[:equalPos]
			paramValue := part[equalPos+1:]

			// Try to parse parameter as number, fallback to string
			if numVal, err := strconv.ParseFloat(paramValue, 64); err == nil {
				params["value"] = numVal
			} else if intVal, err := strconv.ParseInt(paramValue, 10, 64); err == nil {
				params["value"] = intVal
			} else {
				params["value"] = paramValue
			}
		} else {
			// Simple rule without parameters: "required"
			ruleName = part
		}

		// Create validator instance
		validator := registry.Create(ruleName, params)
		if validator != nil {
			rule := ValidationRule{
				Name:       ruleName,
				Validator:  validator,
				Parameters: params,
			}
			rules = append(rules, rule)
		}
	}

	return rules, nil
}

// ValidateValue applies validation rules to a single value.
// This function runs all validation rules and aggregates any errors.
// Use this for simple field validation without cross-field dependencies.
func ValidateValue(fieldName string, value interface{}, rules []ValidationRule) error {
	var errors ErrorList

	for _, rule := range rules {
		if err := rule.Validator.Validate(fieldName, value); err != nil {
			errors.Add(err)
		}
	}

	return errors.AsError()
}

// ValidateValueWithStruct applies validation rules to a single value with access to the full struct.
// This function supports both regular and cross-field validators, making it suitable for
// complex validation scenarios that require access to other fields in the struct.
func ValidateValueWithStruct(fieldName string, value interface{}, rules []ValidationRule, structValue reflect.Value) error {
	var errors ErrorList

	for _, rule := range rules {
		// Check if this is a cross-field validator
		if crossFieldValidator, ok := rule.Validator.(*CrossFieldValidator); ok {
			if err := crossFieldValidator.ValidateWithStruct(fieldName, value, structValue); err != nil {
				errors.Add(err)
			}
		} else {
			// Regular validator
			if err := rule.Validator.Validate(fieldName, value); err != nil {
				errors.Add(err)
			}
		}
	}

	return errors.AsError()
}

// toFloat64 converts various numeric types to float64 for validation purposes
func toFloat64(value interface{}) (float64, error) {
	switch v := value.(type) {
	case float64:
		return v, nil
	case float32:
		return float64(v), nil
	case int:
		return float64(v), nil
	case int8:
		return float64(v), nil
	case int16:
		return float64(v), nil
	case int32:
		return float64(v), nil
	case int64:
		return float64(v), nil
	case uint:
		return float64(v), nil
	case uint8:
		return float64(v), nil
	case uint16:
		return float64(v), nil
	case uint32:
		return float64(v), nil
	case uint64:
		return float64(v), nil
	case string:
		return strconv.ParseFloat(v, 64)
	default:
		return 0, NewParseError("", value, "float64", "cannot convert to numeric value for validation")
	}
}

// toInt converts various numeric types to int for validation purposes
func toInt(value interface{}) (int, error) {
	switch v := value.(type) {
	case int:
		return v, nil
	case int8:
		return int(v), nil
	case int16:
		return int(v), nil
	case int32:
		return int(v), nil
	case int64:
		return int(v), nil
	case uint:
		if v > math.MaxInt64 {
			return 0, NewParseError("", value, "int", "value too large for int")
		}
		return int(v), nil
	case uint8:
		return int(v), nil
	case uint16:
		return int(v), nil
	case uint32:
		return int(v), nil
	case uint64:
		if v > math.MaxInt64 {
			return 0, NewParseError("", value, "int", "value too large for int")
		}
		return int(v), nil
	case float32:
		return int(v), nil
	case float64:
		return int(v), nil
	case string:
		return strconv.Atoi(v)
	default:
		return 0, NewParseError("", value, "int", "cannot convert to integer value for validation")
	}
}
