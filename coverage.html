
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>basic: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vnykmshr/gopantic/examples/basic/main.go (0.0%)</option>
				
				<option value="file1">github.com/vnykmshr/gopantic/pkg/model/coerce.go (0.0%)</option>
				
				<option value="file2">github.com/vnykmshr/gopantic/pkg/model/errors.go (0.0%)</option>
				
				<option value="file3">github.com/vnykmshr/gopantic/pkg/model/parse.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"

        "github.com/vnykmshr/gopantic/pkg/model"
)

// User represents a user in our system
type User struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
        Age   int    `json:"age"`
}

// Product represents a product with various data types
type Product struct {
        ID       uint64  `json:"id"`
        Name     string  `json:"name"`
        Price    float64 `json:"price"`
        InStock  bool    `json:"in_stock"`
        Discount float32 `json:"discount"`
}

// Config represents application configuration
type Config struct {
        MaxRetries int  `json:"max_retries"`
        Enabled    bool `json:"enabled"`
        Timeout    int  `json:"timeout_ms"`
        Debug      bool `json:"debug"`
}

func main() <span class="cov0" title="0">{
        fmt.Println("ðŸš€ gopantic - Basic Parsing Examples")
        fmt.Println("=====================================")

        // Example 1: Basic User parsing with type coercion
        fmt.Println("\n1. User parsing with string-to-int coercion:")
        userJSON := `{"id": "42", "name": "Alice Johnson", "email": "alice@example.com", "age": "28"}`
        fmt.Printf("Input JSON: %s\n", userJSON)

        user, err := model.ParseInto[User]([]byte(userJSON))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing user: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Parsed User: %+v\n", user)
                fmt.Printf("- ID (int): %d\n", user.ID)
                fmt.Printf("- Name: %q\n", user.Name)
                fmt.Printf("- Email: %q\n", user.Email)
                fmt.Printf("- Age (int): %d\n", user.Age)
        }</span>

        // Example 2: Product with mixed types and coercion
        <span class="cov0" title="0">fmt.Println("\n2. Product parsing with mixed type coercion:")
        productJSON := `{"id": "12345", "name": "Wireless Headphones", "price": "99.99", "in_stock": "true", "discount": 0.15}`
        fmt.Printf("Input JSON: %s\n", productJSON)

        product, err := model.ParseInto[Product]([]byte(productJSON))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing product: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Parsed Product: %+v\n", product)
                fmt.Printf("- ID (uint64): %d\n", product.ID)
                fmt.Printf("- Name: %q\n", product.Name)
                fmt.Printf("- Price (float64): $%.2f\n", product.Price)
                fmt.Printf("- InStock (bool): %t\n", product.InStock)
                fmt.Printf("- Discount (float32): %.2f%%\n", product.Discount*100)
        }</span>

        // Example 3: Configuration with boolean coercion
        <span class="cov0" title="0">fmt.Println("\n3. Config parsing with boolean variations:")
        configJSON := `{"max_retries": "5", "enabled": "yes", "timeout_ms": 3000, "debug": 1}`
        fmt.Printf("Input JSON: %s\n", configJSON)

        config, err := model.ParseInto[Config]([]byte(configJSON))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing config: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Parsed Config: %+v\n", config)
                fmt.Printf("- MaxRetries (int): %d\n", config.MaxRetries)
                fmt.Printf("- Enabled (bool): %t\n", config.Enabled)
                fmt.Printf("- Timeout (int): %d ms\n", config.Timeout)
                fmt.Printf("- Debug (bool): %t\n", config.Debug)
        }</span>

        // Example 4: Handling missing fields
        <span class="cov0" title="0">fmt.Println("\n4. Parsing with missing optional fields:")
        partialUserJSON := `{"id": 999, "name": "Bob"}`
        fmt.Printf("Input JSON: %s\n", partialUserJSON)

        partialUser, err := model.ParseInto[User]([]byte(partialUserJSON))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error parsing partial user: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Parsed User: %+v\n", partialUser)
                fmt.Println("- Missing fields default to zero values")
                fmt.Printf("- Email: %q (empty string)\n", partialUser.Email)
                fmt.Printf("- Age: %d (zero value)\n", partialUser.Age)
        }</span>

        // Example 5: Error handling
        <span class="cov0" title="0">fmt.Println("\n5. Error handling for invalid data:")
        invalidJSON := `{"id": "not-a-number", "name": "Invalid User"}`
        fmt.Printf("Input JSON: %s\n", invalidJSON)

        _, err = model.ParseInto[User]([]byte(invalidJSON))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Expected error: %v\n", err)
                fmt.Println("âœ“ gopantic correctly caught the invalid type conversion")
        }</span>

        // Example 6: Demonstrating various boolean coercions
        <span class="cov0" title="0">fmt.Println("\n6. Boolean coercion examples:")
        booleanExamples := []string{
                `{"enabled": "true"}`,
                `{"enabled": "false"}`,
                `{"enabled": "yes"}`,
                `{"enabled": "no"}`,
                `{"enabled": "1"}`,
                `{"enabled": "0"}`,
                `{"enabled": 1}`,
                `{"enabled": 0}`,
        }

        type BoolTest struct {
                Enabled bool `json:"enabled"`
        }

        for _, example := range booleanExamples </span><span class="cov0" title="0">{
                result, err := model.ParseInto[BoolTest]([]byte(example))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  %s â†’ ERROR: %v\n", example, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  %s â†’ %t\n", example, result.Enabled)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\nâœ¨ All examples completed!")
        fmt.Println("gopantic successfully parsed and coerced all the different data types!")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package model

import (
        "fmt"
        "reflect"
        "strconv"
)

// CoerceValue attempts to coerce a value to the target type
func CoerceValue(value interface{}, targetKind reflect.Kind, fieldName string) (interface{}, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return getZeroValue(targetKind), nil
        }</span>

        <span class="cov0" title="0">switch targetKind </span>{
        case reflect.String:<span class="cov0" title="0">
                return coerceToString(value, fieldName)</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return coerceToInt(value, fieldName)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return coerceToUint(value, fieldName)</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return coerceToFloat(value, targetKind, fieldName)</span>
        case reflect.Bool:<span class="cov0" title="0">
                return coerceToBool(value, fieldName)</span>
        default:<span class="cov0" title="0">
                return nil, NewParseError(fieldName, value, targetKind.String(),
                        fmt.Sprintf("coercion to %s not supported", targetKind))</span>
        }
}

// coerceToString converts various types to string
func coerceToString(value interface{}, _ string) (string, error) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return v, nil</span>
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v), nil</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v), nil</span>
        case float32, float64:<span class="cov0" title="0">
                return fmt.Sprintf("%g", v), nil</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return "true", nil
                }</span>
                <span class="cov0" title="0">return "false", nil</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v), nil</span>
        }
}

// coerceToInt converts various types to int64
func coerceToInt(value interface{}, fieldName string) (int64, error) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case int:<span class="cov0" title="0">
                return int64(v), nil</span>
        case int8:<span class="cov0" title="0">
                return int64(v), nil</span>
        case int16:<span class="cov0" title="0">
                return int64(v), nil</span>
        case int32:<span class="cov0" title="0">
                return int64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return v, nil</span>
        case uint:<span class="cov0" title="0">
                if v &gt; 9223372036854775807 </span><span class="cov0" title="0">{ // max int64
                        return 0, NewParseError(fieldName, value, "int64", "value too large for int64")
                }</span>
                <span class="cov0" title="0">return int64(v), nil</span>
        case uint8:<span class="cov0" title="0">
                return int64(v), nil</span>
        case uint16:<span class="cov0" title="0">
                return int64(v), nil</span>
        case uint32:<span class="cov0" title="0">
                return int64(v), nil</span>
        case uint64:<span class="cov0" title="0">
                if v &gt; 9223372036854775807 </span><span class="cov0" title="0">{ // max int64
                        return 0, NewParseError(fieldName, value, "int64", "value too large for int64")
                }</span>
                <span class="cov0" title="0">return int64(v), nil</span>
        case float32:<span class="cov0" title="0">
                return int64(v), nil</span>
        case float64:<span class="cov0" title="0">
                return int64(v), nil</span>
        case string:<span class="cov0" title="0">
                parsed, err := strconv.ParseInt(v, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "int64",
                                fmt.Sprintf("cannot parse string %q as integer: %v", v, err))
                }</span>
                <span class="cov0" title="0">return parsed, nil</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return 1, nil
                }</span>
                <span class="cov0" title="0">return 0, nil</span>
        default:<span class="cov0" title="0">
                return 0, NewParseError(fieldName, value, "int64",
                        fmt.Sprintf("cannot coerce %T to int64", value))</span>
        }
}

// coerceToUint converts various types to uint64
func coerceToUint(value interface{}, fieldName string) (uint64, error) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case uint:<span class="cov0" title="0">
                return uint64(v), nil</span>
        case uint8:<span class="cov0" title="0">
                return uint64(v), nil</span>
        case uint16:<span class="cov0" title="0">
                return uint64(v), nil</span>
        case uint32:<span class="cov0" title="0">
                return uint64(v), nil</span>
        case uint64:<span class="cov0" title="0">
                return v, nil</span>
        case int:<span class="cov0" title="0">
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64", "negative value cannot be coerced to uint64")
                }</span>
                <span class="cov0" title="0">return uint64(v), nil</span>
        case int8:<span class="cov0" title="0">
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64", "negative value cannot be coerced to uint64")
                }</span>
                <span class="cov0" title="0">return uint64(v), nil</span>
        case int16:<span class="cov0" title="0">
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64", "negative value cannot be coerced to uint64")
                }</span>
                <span class="cov0" title="0">return uint64(v), nil</span>
        case int32:<span class="cov0" title="0">
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64", "negative value cannot be coerced to uint64")
                }</span>
                <span class="cov0" title="0">return uint64(v), nil</span>
        case int64:<span class="cov0" title="0">
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64", "negative value cannot be coerced to uint64")
                }</span>
                <span class="cov0" title="0">return uint64(v), nil</span>
        case float32:<span class="cov0" title="0">
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64", "negative value cannot be coerced to uint64")
                }</span>
                <span class="cov0" title="0">return uint64(v), nil</span>
        case float64:<span class="cov0" title="0">
                if v &lt; 0 </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64", "negative value cannot be coerced to uint64")
                }</span>
                <span class="cov0" title="0">return uint64(v), nil</span>
        case string:<span class="cov0" title="0">
                parsed, err := strconv.ParseUint(v, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "uint64",
                                fmt.Sprintf("cannot parse string %q as unsigned integer: %v", v, err))
                }</span>
                <span class="cov0" title="0">return parsed, nil</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return 1, nil
                }</span>
                <span class="cov0" title="0">return 0, nil</span>
        default:<span class="cov0" title="0">
                return 0, NewParseError(fieldName, value, "uint64",
                        fmt.Sprintf("cannot coerce %T to uint64", value))</span>
        }
}

// coerceToFloat converts various types to float32/float64
func coerceToFloat(value interface{}, targetKind reflect.Kind, fieldName string) (float64, error) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case float64:<span class="cov0" title="0">
                return v, nil</span>
        case int:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int8:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int16:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case uint:<span class="cov0" title="0">
                return float64(v), nil</span>
        case uint8:<span class="cov0" title="0">
                return float64(v), nil</span>
        case uint16:<span class="cov0" title="0">
                return float64(v), nil</span>
        case uint32:<span class="cov0" title="0">
                return float64(v), nil</span>
        case uint64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case string:<span class="cov0" title="0">
                bitSize := 64
                if targetKind == reflect.Float32 </span><span class="cov0" title="0">{
                        bitSize = 32
                }</span>
                <span class="cov0" title="0">parsed, err := strconv.ParseFloat(v, bitSize)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, NewParseError(fieldName, value, "float64",
                                fmt.Sprintf("cannot parse string %q as float: %v", v, err))
                }</span>
                <span class="cov0" title="0">return parsed, nil</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return 1.0, nil
                }</span>
                <span class="cov0" title="0">return 0.0, nil</span>
        default:<span class="cov0" title="0">
                return 0, NewParseError(fieldName, value, "float64",
                        fmt.Sprintf("cannot coerce %T to float64", value))</span>
        }
}

// coerceToBool converts various types to bool
func coerceToBool(value interface{}, fieldName string) (bool, error) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                switch v </span>{
                case "true", "True", "TRUE", "1", "yes", "Yes", "YES", "on", "On", "ON":<span class="cov0" title="0">
                        return true, nil</span>
                case "false", "False", "FALSE", "0", "no", "No", "NO", "off", "Off", "OFF", "":<span class="cov0" title="0">
                        return false, nil</span>
                default:<span class="cov0" title="0">
                        return false, NewParseError(fieldName, value, "bool",
                                fmt.Sprintf("cannot parse string %q as boolean", v))</span>
                }
        case int, int8, int16, int32, int64:<span class="cov0" title="0">
                return v != 0, nil</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return v != 0, nil</span>
        case float32, float64:<span class="cov0" title="0">
                return v != 0.0, nil</span>
        default:<span class="cov0" title="0">
                return false, NewParseError(fieldName, value, "bool",
                        fmt.Sprintf("cannot coerce %T to bool", value))</span>
        }
}

// getZeroValue returns the zero value for the given kind
func getZeroValue(kind reflect.Kind) interface{} <span class="cov0" title="0">{
        switch kind </span>{
        case reflect.String:<span class="cov0" title="0">
                return ""</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return int64(0)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return uint64(0)</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return 0.0</span>
        case reflect.Bool:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package model provides core parsing and validation functionality for gopantic.
// It includes type coercion, error handling, and the main ParseInto function
// for converting JSON data into typed Go structs.
package model

import (
        "fmt"
        "strings"
)

// ParseError represents an error that occurred during parsing
type ParseError struct {
        Field   string
        Value   interface{}
        Type    string
        Message string
}

func (e ParseError) Error() string <span class="cov0" title="0">{
        if e.Field != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("parse error on field %q: %s", e.Field, e.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("parse error: %s", e.Message)</span>
}

// NewParseError creates a new ParseError
func NewParseError(field string, value interface{}, targetType, message string) *ParseError <span class="cov0" title="0">{
        return &amp;ParseError{
                Field:   field,
                Value:   value,
                Type:    targetType,
                Message: message,
        }
}</span>

// ValidationError represents a validation failure
type ValidationError struct {
        Field   string
        Value   interface{}
        Rule    string
        Message string
}

func (e ValidationError) Error() string <span class="cov0" title="0">{
        if e.Field != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("validation error on field %q: %s", e.Field, e.Message)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("validation error: %s", e.Message)</span>
}

// NewValidationError creates a new ValidationError
func NewValidationError(field string, value interface{}, rule, message string) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                Field:   field,
                Value:   value,
                Rule:    rule,
                Message: message,
        }
}</span>

// ErrorList represents a collection of errors that can occur during parsing/validation
type ErrorList []error

func (el ErrorList) Error() string <span class="cov0" title="0">{
        if len(el) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(el) == 1 </span><span class="cov0" title="0">{
                return el[0].Error()
        }</span>

        <span class="cov0" title="0">messages := make([]string, 0, len(el))
        for _, err := range el </span><span class="cov0" title="0">{
                messages = append(messages, err.Error())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("multiple errors: %s", strings.Join(messages, "; "))</span>
}

// Add appends an error to the ErrorList
func (el *ErrorList) Add(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                *el = append(*el, err)
        }</span>
}

// HasErrors returns true if the ErrorList contains any errors
func (el ErrorList) HasErrors() bool <span class="cov0" title="0">{
        return len(el) &gt; 0
}</span>

// AsError returns the ErrorList as an error if it contains any errors, nil otherwise
func (el ErrorList) AsError() error <span class="cov0" title="0">{
        if el.HasErrors() </span><span class="cov0" title="0">{
                return el
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package model

import (
        "encoding/json"
        "fmt"
        "reflect"
)

// ParseInto parses raw JSON into a struct of type T with coercion and validation
func ParseInto[T any](raw []byte) (T, error) <span class="cov0" title="0">{
        var zero T
        var errors ErrorList

        // First, unmarshal into a generic map
        var data map[string]interface{}
        if err := json.Unmarshal(raw, &amp;data); err != nil </span><span class="cov0" title="0">{
                errors.Add(fmt.Errorf("json parse error: %w", err))
                return zero, errors.AsError()
        }</span>

        // Create new instance of T
        <span class="cov0" title="0">resultValue := reflect.New(reflect.TypeOf(zero)).Elem()
        resultType := resultValue.Type()

        // Process each field in the struct
        for i := 0; i &lt; resultType.NumField(); i++ </span><span class="cov0" title="0">{
                field := resultType.Field(i)
                fieldValue := resultValue.Field(i)

                // Skip unexported fields
                if !fieldValue.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get JSON key from tag, fallback to field name
                <span class="cov0" title="0">jsonKey := getJSONKey(field)
                if jsonKey == "-" </span><span class="cov0" title="0">{
                        continue</span> // Skip fields with json:"-"
                }

                // Get value from data map
                <span class="cov0" title="0">rawValue, exists := data[jsonKey]
                if !exists </span><span class="cov0" title="0">{
                        // Field not present in JSON, leave as zero value
                        continue</span>
                }

                // Coerce and set the value
                <span class="cov0" title="0">if err := setFieldValue(fieldValue, rawValue, field.Name); err != nil </span><span class="cov0" title="0">{
                        errors.Add(err)
                }</span>
        }

        <span class="cov0" title="0">if errors.HasErrors() </span><span class="cov0" title="0">{
                return zero, errors.AsError()
        }</span>

        <span class="cov0" title="0">return resultValue.Interface().(T), nil</span>
}

// setFieldValue coerces and sets a value on a struct field
func setFieldValue(fieldValue reflect.Value, rawValue interface{}, fieldName string) error <span class="cov0" title="0">{
        fieldKind := fieldValue.Kind()

        // Handle direct assignment for matching types first
        if rawValue != nil &amp;&amp; reflect.TypeOf(rawValue).AssignableTo(fieldValue.Type()) </span><span class="cov0" title="0">{
                fieldValue.Set(reflect.ValueOf(rawValue))
                return nil
        }</span>

        // Use coercion for type conversion
        <span class="cov0" title="0">coercedValue, err := CoerceValue(rawValue, fieldKind, fieldName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the coerced value based on the field kind
        <span class="cov0" title="0">switch fieldKind </span>{
        case reflect.String:<span class="cov0" title="0">
                fieldValue.SetString(coercedValue.(string))</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                fieldValue.SetInt(coercedValue.(int64))</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                fieldValue.SetUint(coercedValue.(uint64))</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                fieldValue.SetFloat(coercedValue.(float64))</span>
        case reflect.Bool:<span class="cov0" title="0">
                fieldValue.SetBool(coercedValue.(bool))</span>
        default:<span class="cov0" title="0">
                return NewParseError(fieldName, rawValue, fieldKind.String(),
                        fmt.Sprintf("unsupported field type: %s", fieldKind))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getJSONKey extracts the JSON key from struct field tags
func getJSONKey(field reflect.StructField) string <span class="cov0" title="0">{
        tag := field.Tag.Get("json")
        if tag == "" </span><span class="cov0" title="0">{
                return field.Name
        }</span>

        // Handle json tag options like "name,omitempty"
        <span class="cov0" title="0">if tag == "-" </span><span class="cov0" title="0">{
                return "-"
        }</span>

        // Split on comma and take first part (the name)
        <span class="cov0" title="0">for i, char := range tag </span><span class="cov0" title="0">{
                if char == ',' </span><span class="cov0" title="0">{
                        return tag[:i]
                }</span>
        }

        <span class="cov0" title="0">return tag</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
