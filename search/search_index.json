{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"gopantic","text":"<p>Type-safe JSON/YAML parsing with validation for Go.</p> <p>Automatic format detection, type coercion, and struct tag validation in a single <code>ParseInto[T]()</code> call.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>type User struct {\n    ID    int    `json:\"id\" validate:\"required,min=1\"`\n    Name  string `json:\"name\" validate:\"required,min=2\"`\n    Email string `json:\"email\" validate:\"required,email\"`\n}\n\ndata := []byte(`{\"id\": \"123\", \"name\": \"Alice\", \"email\": \"alice@example.com\"}`)\n\nuser, err := model.ParseInto[User](data)\n// String \"123\" coerced to int 123, validation applied\n</code></pre>"},{"location":"#features","title":"Features","text":"Feature Description Format Detection JSON or YAML detected automatically Type Coercion <code>\"123\"</code> to <code>123</code>, <code>\"true\"</code> to <code>true</code> Validation Struct tags: <code>validate:\"required,email,min=5\"</code> Cross-Field Compare fields: <code>validate:\"gtfield=Min\"</code> Caching Optional, 5x+ speedup on repeated data"},{"location":"#installation","title":"Installation","text":"<pre><code>go get github.com/vnykmshr/gopantic\n</code></pre> <p>Requires Go 1.23+.</p>"},{"location":"#when-to-use","title":"When to Use","text":"<p>Good fit:</p> <ul> <li>API request parsing with validation</li> <li>Configuration files (JSON/YAML)</li> <li>Data import with type conversion</li> </ul> <p>Not ideal:</p> <ul> <li>Latency-critical hot paths</li> <li>Simple JSON without validation</li> <li>Binary protocols</li> </ul>"},{"location":"#next","title":"Next","text":"<ul> <li>Getting Started</li> <li>Validation Guide</li> <li>API Reference</li> </ul>"},{"location":"architecture/","title":"Architecture &amp; Design","text":""},{"location":"architecture/#core-architecture","title":"Core Architecture","text":""},{"location":"architecture/#package-structure","title":"Package Structure","text":"<pre><code>pkg/model/\n\u251c\u2500\u2500 doc.go          \u2192 Package documentation\n\u251c\u2500\u2500 parse.go        \u2192 Main parsing logic and API (ParseInto, Validate)\n\u251c\u2500\u2500 format.go       \u2192 Format detection and parser abstraction\n\u251c\u2500\u2500 coerce.go       \u2192 Type coercion engine\n\u251c\u2500\u2500 validate.go     \u2192 Validation framework and registry\n\u251c\u2500\u2500 validators.go   \u2192 Built-in validators (required, min, max, etc.)\n\u251c\u2500\u2500 cache.go        \u2192 High-performance caching with FIFO eviction\n\u251c\u2500\u2500 config.go       \u2192 Thread-safe configuration accessors\n\u2514\u2500\u2500 errors.go       \u2192 Error types and aggregation\n</code></pre>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Type Safety First - Leverages Go generics for compile-time type safety</li> <li>Zero-Cost Abstractions - Optional features have no overhead when unused</li> <li>Performance by Default - Optimized for common use cases</li> <li>Idiomatic Go - Struct tags, interfaces, and familiar patterns</li> </ol>"},{"location":"architecture/#parsing-engine","title":"Parsing Engine","text":""},{"location":"architecture/#generic-api-design","title":"Generic API Design","text":"<p>The core parsing API uses Go generics for type safety:</p> <pre><code>func ParseInto[T any](data []byte) (T, error)\nfunc ParseIntoWithFormat[T any](data []byte, format Format) (T, error)\n</code></pre> <p>Benefits: - Compile-time type checking - No runtime type assertions - Clean API without interface{} returns</p>"},{"location":"architecture/#format-abstraction","title":"Format Abstraction","text":"<p>Format detection and parsing are abstracted through interfaces:</p> <pre><code>type FormatParser interface {\n    Parse(data []byte) (map[string]any, error)\n    Format() Format\n}\n\ntype Format int\nconst (\n    FormatJSON Format = iota\n    FormatYAML\n)\n</code></pre> <p>Format Detection Algorithm: 1. Check for JSON markers (<code>{</code>, <code>[</code>) 2. Check for YAML markers (<code>---</code>, <code>:</code>) 3. Default to JSON for ambiguous cases 4. Performance: O(1) with early termination</p>"},{"location":"architecture/#type-coercion","title":"Type Coercion","text":""},{"location":"architecture/#coercion-strategy","title":"Coercion Strategy","text":"<p>Type coercion happens after parsing but before validation:</p> <pre><code>Raw Data \u2192 Parse to map[string]any \u2192 Type Coercion \u2192 Struct \u2192 Validation\n</code></pre>"},{"location":"architecture/#supported-coercions","title":"Supported Coercions","text":"Target From Algorithm <code>int</code> <code>string</code> <code>strconv.Atoi()</code> with error handling <code>float64</code> <code>string</code> <code>strconv.ParseFloat()</code> with precision <code>bool</code> <code>string</code> Custom logic: <code>\"true\"</code>, <code>\"yes\"</code>, <code>\"1\"</code> \u2192 <code>true</code> <code>bool</code> <code>number</code> <code>0</code> \u2192 <code>false</code>, non-zero \u2192 <code>true</code> <code>time.Time</code> <code>string</code> Multiple format attempts (RFC3339, Unix) <code>time.Time</code> <code>number</code> Unix timestamp conversion"},{"location":"architecture/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Validation Metadata Caching - Struct validation rules cached by type (via sync.Map)</li> <li>Fast Path Detection - Skip coercion for matching types</li> <li>Minimal Allocations - Reuse existing values when possible</li> <li>Optimized Time Parsing - Heuristic-based format selection for common cases</li> </ul>"},{"location":"architecture/#validation-framework","title":"Validation Framework","text":""},{"location":"architecture/#tag-based-validation","title":"Tag-Based Validation","text":"<p>Validation rules are specified using struct tags:</p> <pre><code>type User struct {\n    Email string `json:\"email\" validate:\"required,email\"`\n    Age   int    `json:\"age\" validate:\"min=18,max=120\"`\n}\n</code></pre>"},{"location":"architecture/#validator-interface","title":"Validator Interface","text":"<p>All validators implement a common interface:</p> <pre><code>type Validator interface {\n    Validate(fieldName string, value interface{}) error\n}\n</code></pre>"},{"location":"architecture/#built-in-validators","title":"Built-in Validators","text":"Validator Description Performance <code>required</code> Non-zero value check O(1) <code>min/max</code> Numeric/length bounds O(1) <code>email</code> Regex validation O(n) - cached regex <code>alpha</code> Alphabetic characters O(n) <code>alphanum</code> Alphanumeric characters O(n) <code>length</code> Exact length check O(1)"},{"location":"architecture/#error-aggregation","title":"Error Aggregation","text":"<p>Multiple validation errors are collected and returned together:</p> <pre><code>type ErrorList []error\n\nfunc (el *ErrorList) Add(err error) {\n    *el = append(*el, err)\n}\n\nfunc (el ErrorList) AsError() error {\n    if len(el) == 0 {\n        return nil\n    }\n    return fmt.Errorf(\"multiple errors: %s\", strings.Join(errorStrings, \"; \"))\n}\n</code></pre>"},{"location":"architecture/#caching-system","title":"Caching System","text":""},{"location":"architecture/#design-goals","title":"Design Goals","text":"<ul> <li>Transparent: Same API as non-cached parsing</li> <li>Thread-Safe: Concurrent access with minimal locking</li> <li>Configurable: TTL, max entries, namespacing</li> <li>High Performance: Content-based keys with SHA256 hashing</li> </ul>"},{"location":"architecture/#cache-architecture","title":"Cache Architecture","text":"<pre><code>type CachedParser[T any] struct {\n    cache       map[string]cacheEntry\n    mu          sync.RWMutex\n    config      *CacheConfig\n    hits        uint64 // Atomic counter\n    misses      uint64 // Atomic counter\n    stopCleanup chan struct{}\n}\n\ntype CacheConfig struct {\n    TTL             time.Duration // Entry lifetime (default: 1 hour)\n    MaxEntries      int           // FIFO eviction limit (default: 1000)\n    CleanupInterval time.Duration // Background cleanup (default: 30 min)\n}\n</code></pre> <p>Features: - Hit Rate Tracking: Atomic counters for cache hits/misses - Proactive Cleanup: Background goroutine removes expired entries - FIFO Eviction: Oldest entries removed when MaxEntries reached - Thread-Safe: RWMutex for concurrent access</p>"},{"location":"architecture/#key-generation","title":"Key Generation","text":"<p>Cache keys are generated using content-based SHA256 hashing:</p> <pre><code>key = sha256(data)[:16] + \":\" + reflect.TypeOf(T).String()\n</code></pre> <p>Benefits: - Deterministic keys for identical content - Type-safe (different types don't collide) - Efficient 16-byte prefix</p> <p>Limitations: - Even one byte difference invalidates cache - Best for truly identical inputs (config files, retries) - Limited benefit for unique API requests with varying data</p>"},{"location":"architecture/#cache-effectiveness","title":"Cache Effectiveness","text":"<p>Benchmarks show significant speedups for identical inputs:</p> Scenario Uncached Cached Speedup Simple JSON 8.7\u03bcs 1.5\u03bcs 5.8x Complex JSON 27.6\u03bcs 2.6\u03bcs 10.5x Simple YAML 20.8\u03bcs 1.5\u03bcs 13.7x Complex YAML 69.4\u03bcs 2.6\u03bcs 27.2x <p>When to use caching: - Good fit: Parsing static configuration files repeatedly - Good fit: Retrying identical failed requests - Good fit: Processing duplicate messages in queues - Poor fit: Parsing unique API requests (same schema, different data) - Poor fit: Streaming different records from a file</p> <p>Monitoring: Use <code>Stats()</code> to check hit rate and adjust strategy accordingly.</p>"},{"location":"architecture/#error-handling","title":"Error Handling","text":""},{"location":"architecture/#structured-error-types","title":"Structured Error Types","text":"<pre><code>type ParseError struct {\n    Field   string\n    Value   interface{}\n    Type    string\n    Message string\n}\n\ntype ValidationError struct {\n    Field   string\n    Value   interface{}\n    Rule    string\n    Message string\n}\n</code></pre>"},{"location":"architecture/#error-context","title":"Error Context","text":"<p>Errors include full field paths for nested structures:</p> <pre><code>validation error on field \"user.address.zip\": length must be exactly 5 characters\n</code></pre>"},{"location":"architecture/#memory-management","title":"Memory Management","text":""},{"location":"architecture/#allocation-patterns","title":"Allocation Patterns","text":"<ul> <li>Struct Reuse - Target struct allocated once</li> <li>Slice Pre-allocation - Collections sized by JSON array length</li> <li>String Interning - Common field names reused</li> <li>Error Pooling - Error objects reused in high-throughput scenarios</li> </ul>"},{"location":"architecture/#gc-pressure","title":"GC Pressure","text":"<ul> <li>Minimal Heap Allocations - Most work done on stack</li> <li>No Intermediate Objects - Direct parsing to target struct</li> <li>Cache-Friendly - Sequential access patterns where possible</li> </ul>"},{"location":"architecture/#benchmarks-performance","title":"Benchmarks &amp; Performance","text":""},{"location":"architecture/#comparison-with-standard-library","title":"Comparison with Standard Library","text":"Operation Standard JSON gopantic Overhead Simple Parse 1.8\u03bcs 8.7\u03bcs 4.8x With Validation N/A 9.2\u03bcs 5.1x With Coercion N/A 8.9\u03bcs 4.9x"},{"location":"architecture/#memory-usage","title":"Memory Usage","text":"Operation Standard JSON gopantic Overhead Simple Parse 1.2KB 3.8KB 3.2x Complex Parse 4.5KB 11.6KB 2.6x"},{"location":"architecture/#caching-benefits","title":"Caching Benefits","text":"<p>Caching provides substantial improvements for repeated parsing operations, making gopantic comparable to or faster than standard JSON for cache hit scenarios.</p>"},{"location":"architecture/#thread-safety","title":"Thread Safety","text":"<p>All public APIs are thread-safe:</p> <ul> <li>ParseInto - Stateless, fully concurrent</li> <li>CachedParser - RWMutex for cache access</li> <li>Validators - Stateless implementations</li> <li>Format Detection - No shared state</li> </ul>"},{"location":"architecture/#future-considerations","title":"Future Considerations","text":""},{"location":"architecture/#scalability","title":"Scalability","text":"<ul> <li>Parser Pooling - Reuse parser instances for high throughput</li> <li>Custom Allocators - Memory pool for struct allocation</li> <li>SIMD Optimization - Vectorized validation operations</li> </ul>"},{"location":"architecture/#extensibility","title":"Extensibility","text":"<ul> <li>Plugin System - Runtime validator registration</li> <li>Custom Formats - Protocol buffer, MessagePack support</li> <li>Streaming API - Large dataset processing</li> </ul> <p>This architecture provides a solid foundation for high-performance parsing while maintaining Go's principles of simplicity and explicitness.</p>"},{"location":"benchmarks/","title":"Benchmark Comparison","text":"<p>Performance comparison between gopantic and alternatives.</p>"},{"location":"benchmarks/#methodology","title":"Methodology","text":"<p>Hardware: Intel Core i5-8257U CPU @ 1.40GHz (8 cores) Go Version: 1.24.0 OS: macOS (Darwin) Date: 2026-01-19</p> <p>All benchmarks run with: <pre><code>go test -bench=. -benchmem ./tests/... -run=^$\n</code></pre></p>"},{"location":"benchmarks/#results-summary","title":"Results Summary","text":""},{"location":"benchmarks/#validation-only-struct-already-parsed","title":"Validation-Only (struct already parsed)","text":"Library Simple Struct Complex Struct gopantic 1311 ns/op, 81 B/op, 5 allocs 2450 ns/op, 203 B/op, 11 allocs go-playground/validator 1552 ns/op, 88 B/op, 5 allocs 1740 ns/op, 89 B/op, 5 allocs <p>Takeaway: gopantic is ~15% faster for simple validation but go-playground/validator is faster for complex nested structs due to optimized struct traversal.</p>"},{"location":"benchmarks/#parse-validate-json-to-validated-struct","title":"Parse + Validate (JSON to validated struct)","text":"Approach Simple Struct Complex Struct gopantic ParseInto 4264 ns/op, 988 B/op, 28 allocs 12720 ns/op, 2642 B/op, 85 allocs encoding/json + validator 2928 ns/op, 382 B/op, 12 allocs 7796 ns/op, 772 B/op, 26 allocs <p>Takeaway: Standard library combination is faster for pure JSON-to-struct. gopantic's strength is in type coercion and multi-format support.</p>"},{"location":"benchmarks/#parsing-only-no-validation","title":"Parsing Only (no validation)","text":"Library Simple Struct gopantic 2853 ns/op, 896 B/op, 23 allocs encoding/json 1340 ns/op, 288 B/op, 7 allocs <p>Takeaway: encoding/json is ~2x faster for pure JSON parsing. gopantic adds overhead for format detection and coercion infrastructure.</p>"},{"location":"benchmarks/#cached-parsing-gopantic-unique-feature","title":"Cached Parsing (gopantic unique feature)","text":"Mode Performance Cached 645.6 ns/op, 112 B/op, 6 allocs Uncached 6068 ns/op, 1118 B/op, 35 allocs <p>Takeaway: CachedParser provides ~10x performance improvement for repeated parsing of the same data.</p>"},{"location":"benchmarks/#type-coercion-gopantic-unique-feature","title":"Type Coercion (gopantic unique feature)","text":"<pre><code>// Input: {\"id\": \"123\", \"name\": \"John\", \"age\": \"30\"}\n// Output: struct with int id=123, int age=30\n</code></pre> Library Performance gopantic 6491 ns/op, 1882 B/op, 50 allocs encoding/json \u274c Fails (type mismatch error) <p>Takeaway: gopantic automatically coerces string numbers to integers. Standard library requires exact type matching.</p>"},{"location":"benchmarks/#json-vs-yaml-parsing","title":"JSON vs YAML Parsing","text":"Format Performance JSON 4263 ns/op, 989 B/op, 28 allocs YAML 24194 ns/op, 17885 B/op, 161 allocs <p>Takeaway: JSON is ~6x faster than YAML. Use JSON when performance matters.</p>"},{"location":"benchmarks/#format-detection","title":"Format Detection","text":"Operation Performance DetectFormat 2.588 ns/op, 0 B/op, 0 allocs <p>Takeaway: Format detection is essentially free (sub-3ns).</p>"},{"location":"benchmarks/#parallel-performance","title":"Parallel Performance","text":"Approach Performance gopantic 1986 ns/op, 1002 B/op, 28 allocs encoding/json + validator 1634 ns/op, 391 B/op, 12 allocs <p>Takeaway: Both scale well under concurrent load. Standard library combination has lower overhead.</p>"},{"location":"benchmarks/#when-to-use-gopantic","title":"When to Use gopantic","text":"<p>Choose gopantic when: - You need automatic type coercion (string \"123\" \u2192 int 123) - You work with both JSON and YAML formats - You want integrated parse + validate in one step - You use the CachedParser for repeated parsing - You're building configuration parsers, API gateways, or data pipelines</p> <p>Choose encoding/json + validator when: - Pure performance is critical - You only use JSON format - Your data always has exact type matching - You're processing high-volume, well-typed streams</p>"},{"location":"benchmarks/#detailed-results","title":"Detailed Results","text":"<pre><code>BenchmarkValidation_Gopantic_Simple-8                 921296          1311 ns/op          81 B/op          5 allocs/op\nBenchmarkValidation_Playground_Simple-8               799057          1552 ns/op          88 B/op          5 allocs/op\nBenchmarkValidation_Gopantic_Complex-8                457716          2450 ns/op         203 B/op         11 allocs/op\nBenchmarkValidation_Playground_Complex-8              686307          1740 ns/op          89 B/op          5 allocs/op\n\nBenchmarkParseValidate_Gopantic_Simple-8              279391          4264 ns/op         988 B/op         28 allocs/op\nBenchmarkParseValidate_StdJSON_Simple-8               404677          2928 ns/op         382 B/op         12 allocs/op\nBenchmarkParseValidate_Gopantic_Complex-8              95326         12720 ns/op        2642 B/op         85 allocs/op\nBenchmarkParseValidate_StdJSON_Complex-8              178778          7796 ns/op         772 B/op         26 allocs/op\n\nBenchmarkParse_Gopantic_NoValidation-8                414764          2853 ns/op         896 B/op         23 allocs/op\nBenchmarkParse_StdJSON-8                              891786          1340 ns/op         288 B/op          7 allocs/op\n\nBenchmarkCachedParsing-8                             1799991           645.6 ns/op       112 B/op          6 allocs/op\nBenchmarkCoercion_Gopantic-8                          181592          6491 ns/op        1882 B/op         50 allocs/op\n\nBenchmarkFormat_JSON-8                                274134          4263 ns/op         989 B/op         28 allocs/op\nBenchmarkFormat_YAML-8                                 49485         24194 ns/op       17885 B/op        161 allocs/op\nBenchmarkFormatDetect-8                             464196988            2.588 ns/op           0 B/op          0 allocs/op\n\nBenchmarkParallel_Gopantic_Simple-8                   653206          1986 ns/op        1002 B/op         28 allocs/op\nBenchmarkParallel_StdJSON_Simple-8                    948778          1634 ns/op         391 B/op         12 allocs/op\n</code></pre>"},{"location":"benchmarks/#reproducing-benchmarks","title":"Reproducing Benchmarks","text":"<pre><code># Clone the repository\ngit clone https://github.com/vnykmshr/gopantic.git\ncd gopantic\n\n# Run all benchmarks\ngo test -bench=. -benchmem ./tests/... -run=^$\n\n# Run specific benchmark categories\ngo test -bench=Validation -benchmem ./tests/...\ngo test -bench=ParseValidate -benchmem ./tests/...\ngo test -bench=Parallel -benchmem ./tests/...\n</code></pre>"},{"location":"benchmarks/#notes","title":"Notes","text":"<ol> <li> <p>Benchmark stability: Results may vary by \u00b110% between runs due to CPU frequency scaling and system load.</p> </li> <li> <p>Validation scope: go-playground/validator supports more validation rules out of the box. gopantic focuses on core validators with extensibility.</p> </li> <li> <p>Memory vs CPU: gopantic trades some memory for features like type coercion and format flexibility.</p> </li> <li> <p>Real-world usage: Microbenchmarks don't capture all production scenarios. Profile your specific workload.</p> </li> </ol>"},{"location":"building-gopantic/","title":"Building gopantic","text":"<p>Why another parsing library? What problems does it solve?</p>"},{"location":"building-gopantic/#the-problem","title":"The Problem","text":"<p>Go's <code>encoding/json</code> deserializes. That's it. Everything else is your problem:</p> <pre><code>// What you actually do for every API endpoint\nvar raw map[string]interface{}\njson.Unmarshal(data, &amp;raw)\n\nid, ok := raw[\"id\"].(float64)  // JSON numbers are float64\nif !ok {\n    return errors.New(\"invalid id\")\n}\nuser := User{ID: int(id)}  // Manual conversion\n\nvalidate := validator.New()\nif err := validate.Struct(user); err != nil {\n    return err\n}\n</code></pre> <p>This pattern repeats everywhere: parse, assert types, convert, validate. Four steps, three libraries, scattered error handling.</p>"},{"location":"building-gopantic/#the-solution","title":"The Solution","text":"<p>One function that answers: \"Is this data valid and usable?\"</p> <pre><code>user, err := model.ParseInto[User](data)\n</code></pre> <p>Parse. Coerce types. Validate. Return all errors. Done.</p>"},{"location":"building-gopantic/#design-decisions","title":"Design Decisions","text":""},{"location":"building-gopantic/#generics-for-type-safety","title":"Generics for Type Safety","text":"<p>Returns <code>User</code>, not <code>interface{}</code>. Compile-time checking. IDE autocompletion works.</p> <p>Trade-off: Requires Go 1.18+. Worth it.</p>"},{"location":"building-gopantic/#automatic-type-coercion","title":"Automatic Type Coercion","text":"<p>APIs send <code>\"123\"</code> instead of <code>123</code>. Mobile apps send everything as strings. Configuration files mix types.</p> <p>gopantic handles this transparently:</p> <pre><code>// Input: {\"id\": \"42\", \"active\": \"true\"}\n// Result: User{ID: 42, Active: true}\n</code></pre> <p>When to disable: Financial calculations requiring exact decimal types. Strict contracts where coercion masks errors.</p>"},{"location":"building-gopantic/#tag-based-validation","title":"Tag-Based Validation","text":"<p>Validation rules live with type definitions:</p> <pre><code>type Product struct {\n    SKU   string  `json:\"sku\" validate:\"required,len=8\"`\n    Price float64 `json:\"price\" validate:\"min=0.01\"`\n}\n</code></pre> <p>No separate validation layer. No drift between struct and rules.</p>"},{"location":"building-gopantic/#error-aggregation","title":"Error Aggregation","text":"<p>Return all errors, not just the first:</p> <pre><code>multiple errors:\n  field 'SKU': length must be exactly 8;\n  field 'Price': must be at least 0.01\n</code></pre> <p>Users fix everything in one iteration.</p>"},{"location":"building-gopantic/#optional-caching","title":"Optional Caching","text":"<p>For repeated parsing of identical data (config files, retries, deduplication):</p> <pre><code>parser := model.NewCachedParser[Config](nil)\ndefer parser.Close()\n\nconfig, _ := parser.Parse(data)  // Cache miss\nconfig, _ := parser.Parse(data)  // Cache hit, 5-10x faster\n</code></pre> <p>FIFO eviction. TTL expiration. Thread-safe.</p>"},{"location":"building-gopantic/#architecture","title":"Architecture","text":"<pre><code>Raw Bytes \u2192 Format Detection \u2192 Parse \u2192 Coerce \u2192 Map to Struct \u2192 Validate \u2192 Result\n</code></pre> <p>Format Detection: JSON markers (<code>{</code>, <code>[</code>) or YAML markers (<code>---</code>, <code>:</code>). O(1).</p> <p>Coercion: String to int/float/bool/time. Fails fast on invalid conversions.</p> <p>Validation: Cached by <code>reflect.Type</code>. First parse pays reflection cost; subsequent parses reuse.</p>"},{"location":"building-gopantic/#performance","title":"Performance","text":"Scenario vs stdlib Notes Parse only 4-5x slower Includes coercion Parse + validate 2.4x slower Apples to apples Cached parse 5-10x faster For identical inputs <p>For most backend services, the convenience justifies the overhead. For ultra-high-frequency paths, profile first.</p>"},{"location":"building-gopantic/#when-to-use","title":"When to Use","text":"<p>Good fit: API validation, config parsing, webhook handlers, data pipelines.</p> <p>Poor fit: Ultra-low-latency trading, embedded systems, Protocol Buffers, streaming large datasets.</p>"},{"location":"building-gopantic/#lessons-learned","title":"Lessons Learned","text":"<ol> <li> <p>Cache reflection metadata - Parsing tags on every request killed performance. Caching by type reduced overhead from 15% to 5%.</p> </li> <li> <p>Aggregate errors - Early versions stopped at first error. Users hated the iteration loops.</p> </li> <li> <p>Generics over codegen - Code generation (<code>easyjson</code>) is faster but complicates workflows. Generics provide 90% of the benefit with zero build overhead.</p> </li> <li> <p>Document cache effectiveness - Content-based keys work for config files, not for unique API requests. Set proper expectations.</p> </li> </ol>"},{"location":"building-gopantic/#examples","title":"Examples","text":"<p>See examples/ for runnable code:</p> <ul> <li>quickstart/ - Basic parsing and validation</li> <li>api_validation/ - HTTP handler patterns</li> <li>cross_field_validation/ - Password confirmation, field comparisons</li> <li>cache_demo/ - Caching for repeated parsing</li> <li>yaml/ - Configuration file parsing</li> <li>pointers/ - Optional fields with nil handling</li> <li>postgresql_jsonb/ - PostgreSQL JSONB with json.RawMessage</li> </ul>"},{"location":"building-gopantic/#next","title":"Next","text":"<ul> <li>Getting Started - Installation and basic usage</li> <li>API Reference - Complete API documentation</li> <li>Validation Guide - All validators and custom rules</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#140-2026-01-19","title":"[1.4.0] - 2026-01-19","text":""},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Structure depth limit: Added <code>MaxStructureDepth</code> configuration (default: 64) to protect against deeply nested JSON/YAML causing resource exhaustion</li> <li>Sensitive field sanitization: New <code>SanitizedValue()</code> method on <code>ValidationError</code> automatically redacts sensitive field values (passwords, tokens, API keys) in error output</li> <li>Configurable patterns: Thread-safe <code>GetSensitiveFieldPatterns()</code>, <code>SetSensitiveFieldPatterns()</code>, and <code>AddSensitiveFieldPattern()</code> for customizing sensitive field detection</li> </ul>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Fuzzing tests: 7 fuzz targets for parser and coercion edge case discovery</li> <li>Validator registry tests: Comprehensive coverage for all 7 registry methods</li> <li>Depth limit tests: Tests for JSON and YAML depth enforcement</li> <li>Benchmark comparison document: Performance comparison with go-playground/validator</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>ToStructuredReport(): Now uses sanitized values for sensitive fields</li> <li>Error handling: <code>IsSensitiveField()</code> exported for custom sanitization logic</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Fixed validator documentation: Corrected docs to accurately reflect built-in validators (removed non-existent validators like <code>url</code>, <code>uuid</code>, <code>oneof</code>)</li> <li>Benchmark guide: New <code>docs/benchmarks.md</code> with methodology and results</li> <li>Validation guide: Clarified custom validator registration patterns</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Added <code>go-playground/validator/v10</code> as test dependency for comparison benchmarks</li> <li>Fuzzing tests exercise ParseInto and CoerceValue with various input patterns</li> <li>Registry tests verify validator registration and factory patterns</li> </ul>"},{"location":"changelog/#130-2026-01-19","title":"[1.3.0] - 2026-01-19","text":""},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li>Fixed cache key hash collision vulnerability: Cache keys now use full SHA256 hash instead of truncated 64-bit hash for large inputs (\u22651KB), preventing potential cache poisoning attacks</li> <li>Thread-safe configuration: Added Get/Set functions with synchronization for <code>MaxInputSize</code>, <code>MaxCacheSize</code>, and <code>MaxValidationDepth</code></li> <li>SECURITY.md: Updated comprehensive security policy with detailed documentation</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Documentation site: New documentation at vnykmshr.github.io/gopantic with MkDocs Material theme</li> <li>Dark/light mode toggle</li> <li>Full-text search</li> <li>Organized guide and reference sections</li> <li>\"Why gopantic\" narrative: New building-gopantic.md explaining the problem, solution, and design decisions</li> <li>Expanded cache tests: Cache module test coverage significantly improved</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Documentation structure: Reorganized docs into clear guide/ and reference/ hierarchy</li> <li>Documentation quality: All docs reviewed for accuracy and clarity</li> <li>PostgreSQL tutorial: Moved to examples/postgresql_jsonb/ as runnable code</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Custom validator docs: Corrected function signatures in validation.md to match actual API</li> <li>architecture.md: Fixed cache terminology (FIFO, not LRU) and package file list</li> <li>migration.md: Corrected validator references (<code>alphanum</code> not <code>alphanumeric</code>)</li> </ul>"},{"location":"changelog/#deprecation-notices","title":"Deprecation Notices","text":"<ul> <li>Direct modification of <code>MaxInputSize</code>, <code>MaxCacheSize</code>, <code>MaxValidationDepth</code> is deprecated</li> <li>Use <code>GetMaxInputSize()</code>/<code>SetMaxInputSize()</code> and equivalent functions instead</li> <li>Old variables still work but may be removed in v2.0</li> </ul>"},{"location":"changelog/#120-2025-11-23","title":"[1.2.0] - 2025-11-23","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li><code>json.RawMessage</code> support: Full support for <code>json.RawMessage</code> fields, enabling flexible metadata storage and PostgreSQL JSONB integration</li> <li>Standalone <code>Validate[T](*T)</code> function: Validate structs independently of parsing, allowing validation of data from any source (database, environment variables, etc.)</li> <li>Hybrid unmarshal strategy: Uses standard <code>encoding/json</code> and <code>gopkg.in/yaml.v3</code> as base unmarshaler, then applies selective type coercion only where needed</li> <li>Recursive nested struct validation: Validation now properly handles deeply nested structs and pointer-to-struct fields</li> <li>Performance optimizations:</li> <li>Validation tag caching for 10-20% faster repeated parsing</li> <li>No-validation fast path for types without validation rules</li> <li>FNV-1a hash for cache keys on small inputs (&lt;1KB)</li> <li>Result: 46% faster parsing, 64% less memory, 67% fewer allocations</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Parsing architecture: Refactored to use standard library unmarshalers first, with fallback to map-based coercion for complex type conversion cases</li> <li>Better ecosystem compatibility: Works seamlessly with custom <code>UnmarshalJSON</code> methods and standard Go patterns</li> <li>Performance vs stdlib JSON: Gap reduced from 3.9x slower to 1.7x slower</li> <li>Test suite consolidation: Reorganized from 2 directories to flat structure, added concurrency and edge case tests (56\u2192100 tests)</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Issue #10: <code>json.RawMessage</code> fields no longer cause \"cannot coerce map to slice\" errors</li> <li>Nested struct validation: Fixed validation not being applied to nested struct fields</li> <li>Cross-field validation: Improved handling of cross-field validators in complex struct hierarchies</li> </ul>"},{"location":"changelog/#code-quality","title":"Code Quality","text":"<ul> <li>Removed dead code: Eliminated 147 lines of unused functions (<code>applySelectiveCoercion</code>, <code>ParseIntoCached</code> wrappers)</li> <li>Fixed magic numbers: Replaced hardcoded values with <code>math.MaxInt64</code> constant (4 locations)</li> <li>Consolidated duplicate functions: Unified <code>getFieldKey</code> implementation, removed duplicate type converters</li> <li>Reduced documentation verbosity: Streamlined package docs from 100 to 29 lines while retaining essential information</li> <li>Production-ready cleanup: Removed AI-generated bloat, improved code maintainability and consistency</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Added <code>json.RawMessage</code> usage examples to README</li> <li>Added standalone <code>Validate()</code> function documentation</li> <li>Added PostgreSQL JSONB integration pattern examples</li> <li>Updated README with concise performance metrics</li> <li>Comprehensive test suite for <code>json.RawMessage</code> scenarios (tests/rawmessage_test.go)</li> <li>Consolidated and compacted all documentation for better readability</li> </ul>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<p>None - this release is fully backward compatible. Existing code continues to work unchanged.</p>"},{"location":"changelog/#migration-notes","title":"Migration Notes","text":"<p>New recommended pattern for <code>json.RawMessage</code> fields:</p> <pre><code>type Request struct {\n    Name        string          `json:\"name\" validate:\"required\"`\n    MetadataRaw json.RawMessage `json:\"metadata,omitempty\"`\n}\n\n// Now works seamlessly\nreq, err := model.ParseInto[Request](body)\n</code></pre> <p>New standalone validation pattern:</p> <pre><code>var req Request\njson.Unmarshal(body, &amp;req)  // Use standard library\nmodel.Validate(&amp;req)         // Apply gopantic validation\n</code></pre>"},{"location":"changelog/#110-2025-10-30","title":"[1.1.0] - 2025-10-30","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Validation metadata caching: Struct validation rules now cached by type using <code>sync.Map</code> for 10-20% performance improvement on repeated parsing</li> <li>Cache hit rate tracking: <code>CachedParser.Stats()</code> now returns actual hit rate via atomic counters for better observability</li> <li>Proactive cache cleanup: Background goroutine periodically removes expired entries (configurable via <code>CleanupInterval</code>)</li> <li>Input size protection: Added <code>MaxInputSize</code> variable (default 10MB) to prevent DoS attacks from oversized inputs</li> <li>Security policy: Added SECURITY.md with vulnerability disclosure process and security best practices</li> <li>Migration guide: Comprehensive docs/migration.md covering migration from encoding/json, validator, and YAML libraries</li> <li>Dependabot automation: Weekly automated dependency updates for Go modules and GitHub Actions</li> <li><code>ClearValidationCache()</code> function: Manual cache invalidation for dynamic validator registration scenarios</li> <li><code>Close()</code> method: Properly stops background cleanup goroutine on CachedParser</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Optimized time parsing: Heuristic-based format selection tries RFC3339/ISO 8601 first when 'T' detected at position 10</li> <li>Cache configuration: Added <code>CleanupInterval</code> field to <code>CacheConfig</code> (default: 30 minutes)</li> <li>Documentation clarity: Updated README and architecture docs to clarify cache use cases and limitations</li> <li>golangci-lint v2 compatibility: Updated configuration for golangci-lint v2 with version pinning for consistency</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>golangci-lint configuration: Fixed YAML syntax and made compatible with v2.x</li> <li>Test coverage reporting: Added <code>-coverpkg=./pkg/...</code> flag to properly capture package coverage</li> <li>CI cleanup: Removed unused Redis service configurations from all GitHub Actions workflows</li> <li>Linter version consistency: Pinned golangci-lint to v2.5.0 in CI to match local development</li> </ul>"},{"location":"changelog/#performance","title":"Performance","text":"<ul> <li>10-20% faster validation for repeated struct types via metadata caching</li> <li>Optimized time parsing for common RFC3339 timestamps</li> <li>Proactive cleanup prevents memory accumulation in long-running services</li> </ul>"},{"location":"changelog/#security_2","title":"Security","text":"<ul> <li>DoS protection via configurable input size limits</li> <li>Documentation of error message content for secure handling of sensitive data</li> <li>Automated dependency vulnerability scanning</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>New migration guide (200+ lines) covering common patterns</li> <li>Security policy with vulnerability reporting process</li> <li>Enhanced API docs with security considerations</li> <li>Clarified cache effectiveness and appropriate use cases</li> </ul>"},{"location":"changelog/#101-2025-01-16","title":"[1.0.1] - 2025-01-16","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>GitHub Actions workflows - Resolved tar cache extraction failures in nightly performance monitoring</li> <li>Benchmark targets - Corrected Make targets to point to correct tests directory structure</li> <li>CI pipeline - Fixed lint and security job failures, added proper SARIF upload permissions</li> <li>Repository security - Removed non-existent security scan actions and corrected gosec paths</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Documentation script - Streamlined generate-docs.sh for cleaner, minimal output</li> <li>Build artifacts - Enhanced .gitignore for better profiling and benchmark file management</li> <li>Code quality - Removed TODO comments from production code for release readiness</li> </ul>"},{"location":"changelog/#100-2025-01-13","title":"[1.0.0] - 2025-01-13","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>JSON/YAML parsing with automatic format detection</li> <li>Type coercion - automatic conversion between compatible types (<code>\"123\"</code> \u2192 <code>123</code>, <code>\"true\"</code> \u2192 <code>true</code>)</li> <li>Comprehensive validation using struct tags (<code>validate:\"required,email,min=5\"</code>)</li> <li>Cross-field validation - validate fields against each other (password confirmation, field comparisons)</li> <li>Built-in validators: <code>required</code>, <code>min</code>, <code>max</code>, <code>email</code>, <code>alpha</code>, <code>alphanum</code>, <code>length</code></li> <li>Nested struct support with full validation propagation</li> <li>Array and slice parsing with element validation</li> <li>Time parsing support (RFC3339, Unix timestamps, custom formats)</li> <li>Pointer support for optional fields (<code>*string</code>, <code>*int</code>)</li> <li>High-performance caching - 5-27x speedup for repeated parsing operations</li> <li>Thread-safe concurrent parsing operations</li> <li>Generics support for type-safe parsing with <code>ParseInto[T]()</code></li> <li>Structured error reporting with field paths and detailed context</li> <li>Custom validator registration for domain-specific validation rules</li> <li>Zero dependencies (except optional YAML support via <code>gopkg.in/yaml.v3</code>)</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Single-function API: <code>model.ParseInto[T](data)</code> covers most use cases</li> <li>Automatic format detection (JSON vs YAML)</li> <li>Comprehensive example collection covering real-world scenarios</li> <li>Production-ready with extensive test coverage</li> <li>Compatible with Go 1.23+</li> </ul>"},{"location":"changelog/#examples","title":"Examples","text":"<ul> <li>Basic parsing with type coercion</li> <li>Validation examples with multiple error handling</li> <li>Cross-field validation (password confirmation, email differences)</li> <li>Time parsing with multiple format support</li> <li>YAML configuration parsing</li> <li>API request/response validation</li> <li>Pointer field handling for optional data</li> <li>High-performance caching usage</li> </ul>"},{"location":"changelog/#version-format","title":"Version Format","text":"<p>This project uses Semantic Versioning: - MAJOR version for incompatible API changes - MINOR version for backwards-compatible functionality additions - PATCH version for backwards-compatible bug fixes</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>go get github.com/vnykmshr/gopantic\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>Define a struct with JSON tags and validation rules:</p> <pre><code>type User struct {\n    ID       int    `json:\"id\" validate:\"required,min=1\"`\n    Username string `json:\"username\" validate:\"required,min=3,max=50\"`\n    Email    string `json:\"email\" validate:\"required,email\"`\n    Age      int    `json:\"age\" validate:\"min=0,max=150\"`\n}\n</code></pre> <p>Parse data:</p> <pre><code>import \"github.com/vnykmshr/gopantic/pkg/model\"\n\ndata := []byte(`{\"id\": \"123\", \"username\": \"alice\", \"email\": \"alice@example.com\", \"age\": \"25\"}`)\nuser, err := model.ParseInto[User](data)\n</code></pre> <p>String <code>\"123\"</code> is coerced to int <code>123</code>.</p>"},{"location":"getting-started/#yaml","title":"YAML","text":"<p>Format detected automatically:</p> <pre><code>yamlData := []byte(`\nid: 456\nusername: bob\nemail: bob@example.com\nage: 30\n`)\n\nuser, err := model.ParseInto[User](yamlData)\n</code></pre> <p>Explicit format when known:</p> <pre><code>user, err := model.ParseIntoWithFormat[User](data, model.FormatJSON)\nuser, err := model.ParseIntoWithFormat[User](yamlData, model.FormatYAML)\n</code></pre>"},{"location":"getting-started/#validation","title":"Validation","text":"<p>Built-in validators:</p> Validator Example Description <code>required</code> <code>validate:\"required\"</code> Non-zero value <code>min</code> <code>validate:\"min=5\"</code> Min value or length <code>max</code> <code>validate:\"max=100\"</code> Max value or length <code>length</code> <code>validate:\"length=10\"</code> Exact length <code>email</code> <code>validate:\"email\"</code> Email format <code>alpha</code> <code>validate:\"alpha\"</code> Letters only <code>alphanum</code> <code>validate:\"alphanum\"</code> Letters and numbers <p>Combine with commas:</p> <pre><code>Email string `json:\"email\" validate:\"required,email\"`\nAge   int    `json:\"age\" validate:\"required,min=18,max=120\"`\n</code></pre> <p>See Validation Guide for all validators.</p>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>user, err := model.ParseInto[User](data)\nif err != nil {\n    // \"field 'email' validation failed: invalid email format\"\n    log.Printf(\"Error: %v\", err)\n}\n</code></pre> <p>Error messages include field values. Do not expose to untrusted clients.</p>"},{"location":"getting-started/#caching","title":"Caching","text":"<p>For repeated parsing of identical data:</p> <pre><code>parser := model.NewCachedParser[User](nil)\ndefer parser.Close()\n\nuser1, _ := parser.Parse(data)  // Cache miss\nuser2, _ := parser.Parse(data)  // Cache hit\n</code></pre> <p>See Caching Guide.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Thread-safe accessors:</p> <pre><code>model.SetMaxInputSize(5 * 1024 * 1024)  // 5MB (default: 10MB)\nmodel.SetMaxValidationDepth(16)          // default: 32\nmodel.SetMaxCacheSize(500)               // default: 1000\n</code></pre>"},{"location":"getting-started/#next","title":"Next","text":"<ul> <li>Validation Guide</li> <li>Caching Guide</li> <li>API Reference</li> </ul>"},{"location":"migration/","title":"Migration Guide","text":""},{"location":"migration/#quick-comparison","title":"Quick Comparison","text":"Task Standard Libraries gopantic Parse + Validate <code>json.Unmarshal()</code> + <code>validate.Struct()</code> <code>model.ParseInto[T]()</code> Parse YAML <code>yaml.Unmarshal()</code> + <code>validate.Struct()</code> <code>model.ParseInto[T]()</code> Type coercion Manual conversion Automatic Validation Separate step Integrated Custom validators <code>RegisterValidation()</code> <code>RegisterGlobalFunc()</code> Error handling <code>ValidationErrors</code> Structured error types"},{"location":"migration/#migration-examples","title":"Migration Examples","text":""},{"location":"migration/#from-encodingjson-validator","title":"From encoding/json + validator","text":"<p>Before: <pre><code>import (\n    \"encoding/json\"\n    \"github.com/go-playground/validator/v10\"\n)\n\nfunc parseUser(data []byte) (*User, error) {\n    var user User\n    if err := json.Unmarshal(data, &amp;user); err != nil {\n        return nil, err\n    }\n    validate := validator.New()\n    if err := validate.Struct(user); err != nil {\n        return nil, err\n    }\n    return &amp;user, nil\n}\n</code></pre></p> <p>After: <pre><code>import \"github.com/vnykmshr/gopantic/pkg/model\"\n\nfunc parseUser(data []byte) (User, error) {\n    return model.ParseInto[User](data)\n}\n</code></pre></p> <p>Key benefits: Single call, automatic type coercion (<code>{\"id\": \"42\"}</code> works), generics return <code>User</code> directly, YAML support with same API.</p>"},{"location":"migration/#from-encodingjson-manual-validation","title":"From encoding/json (manual validation)","text":"<p>Before: <pre><code>func loadConfig(data []byte) (*Config, error) {\n    var cfg Config\n    if err := json.Unmarshal(data, &amp;cfg); err != nil {\n        return nil, err\n    }\n    if cfg.Port &lt; 1 || cfg.Port &gt; 65535 {\n        return nil, errors.New(\"invalid port\")\n    }\n    if cfg.Host == \"\" {\n        return nil, errors.New(\"host required\")\n    }\n    return &amp;cfg, nil\n}\n</code></pre></p> <p>After: <pre><code>type Config struct {\n    Port int    `json:\"port\" validate:\"required,min=1,max=65535\"`\n    Host string `json:\"host\" validate:\"required\"`\n}\n\nfunc loadConfig(data []byte) (Config, error) {\n    return model.ParseInto[Config](data)\n}\n</code></pre></p> <p>Key benefits: Declarative validation via tags, automatic field names in errors, type coercion (<code>\"8080\"</code> \u2192 <code>8080</code>).</p>"},{"location":"migration/#from-yaml-libraries","title":"From YAML libraries","text":"<p>Replace <code>yaml.Unmarshal()</code> + validator with <code>model.ParseInto[T]()</code>. Format auto-detected, validation integrated.</p>"},{"location":"migration/#migration-checklist","title":"Migration Checklist","text":""},{"location":"migration/#1-update-imports","title":"1. Update imports","text":"<pre><code>- import \"encoding/json\"\n- import \"github.com/go-playground/validator/v10\"\n+ import \"github.com/vnykmshr/gopantic/pkg/model\"\n</code></pre>"},{"location":"migration/#2-update-validation-tags","title":"2. Update validation tags","text":"<p>Most validator tags work as-is:</p> validator gopantic Notes <code>required</code>, <code>min=N</code>, <code>max=N</code> Same Compatible <code>email</code> <code>email</code> Simplified regex <code>len=8</code> <code>len=8</code> Same <code>eqfield=Password</code> <code>eqfield=Password</code> Cross-field validators supported <code>dive</code> N/A Nested validation automatic"},{"location":"migration/#3-handle-type-coercion","title":"3. Handle type coercion","text":"<p>Remove manual string-to-type conversion. gopantic handles automatically: <pre><code>{\"age\": \"25\"}  // Now works with Age int field\n</code></pre></p>"},{"location":"migration/#4-update-error-handling","title":"4. Update error handling","text":"<p>Before: <pre><code>if validationErrs, ok := err.(validator.ValidationErrors); ok {\n    for _, fieldErr := range validationErrs {\n        fmt.Printf(\"Field: %s, Error: %s\\n\", fieldErr.Field(), fieldErr.Tag())\n    }\n}\n</code></pre></p> <p>After: <pre><code>// Errors already formatted: \"validation error on field 'Email': must be a valid email\"\nlog.Error(err)\n\n// Or type-check structured errors\nif parseErr, ok := err.(*model.ParseError); ok {\n    fmt.Printf(\"Field: %s, Type: %s\\n\", parseErr.Field, parseErr.Type)\n}\n</code></pre></p>"},{"location":"migration/#5-update-custom-validators","title":"5. Update custom validators","text":"<p>Before: <pre><code>validate.RegisterValidation(\"strong_password\", func(fl validator.FieldLevel) bool {\n    password := fl.Field().String()\n    return len(password) &gt;= 8 &amp;&amp; hasUpperLower(password)\n})\n</code></pre></p> <p>After: <pre><code>model.RegisterGlobalFunc(\"strong_password\", func(fieldName string, value interface{}, params map[string]interface{}) error {\n    password, ok := value.(string)\n    if !ok || len(password) &lt; 8 || !hasUpperLower(password) {\n        return model.NewValidationError(fieldName, value, \"strong_password\", \"password must be 8+ chars with upper/lowercase\")\n    }\n    return nil\n})\n</code></pre></p>"},{"location":"migration/#common-gotchas","title":"Common Gotchas","text":""},{"location":"migration/#required-vs-zero-values","title":"Required vs zero values","text":"<pre><code>Port int `json:\"port\"`                  // Allows 0\nPort int `json:\"port\" validate:\"required\"` // Rejects 0\n</code></pre>"},{"location":"migration/#optional-fields","title":"Optional fields","text":"<p>Use pointers for optional fields: <pre><code>Phone *string `json:\"phone\"` // nil = not provided, \"\" = empty string provided\n</code></pre></p>"},{"location":"migration/#nested-validation","title":"Nested validation","text":"<p>Automatic for nested structs. All <code>validate</code> tags in nested structs are checked: <pre><code>type User struct {\n    Address Address `json:\"address\"` // Address fields validated automatically\n}\n</code></pre></p>"},{"location":"migration/#tag-order","title":"Tag order","text":"<p>Tags can appear in any order: <code>json:\"name\" validate:\"required\"</code> or <code>validate:\"required\" json:\"name\"</code></p>"},{"location":"migration/#performance-tips","title":"Performance Tips","text":""},{"location":"migration/#caching-for-repeated-parsing","title":"Caching for repeated parsing","text":"<pre><code>parser := model.NewCachedParser[User](nil)\ndefer parser.Close()\n\nuser1, _ := parser.Parse(data) // Cache miss\nuser2, _ := parser.Parse(data) // Cache hit\n</code></pre>"},{"location":"migration/#input-size-limits","title":"Input size limits","text":"<pre><code>model.MaxInputSize = 5 * 1024 * 1024  // 5MB limit\nmodel.MaxInputSize = 0                 // No limit\n</code></pre>"},{"location":"migration/#validation-depth-control","title":"Validation depth control","text":"<pre><code>model.MaxValidationDepth = 32  // Default, prevents stack overflow\n</code></pre>"},{"location":"migration/#getting-help","title":"Getting Help","text":"<p>If you encounter migration issues:</p> <ol> <li>Check API documentation for function details</li> <li>Review examples for common patterns</li> <li>File issues at https://github.com/vnykmshr/gopantic/issues with:</li> <li>Current code before migration</li> <li>Error or unexpected behavior</li> <li>Go version and gopantic version</li> </ol>"},{"location":"guide/caching/","title":"Caching Guide","text":"<p>Optional caching for repeated parsing of identical data. Provides 5x+ speedup on cache hits.</p>"},{"location":"guide/caching/#when-to-use-caching","title":"When to Use Caching","text":"<p>Good use cases:</p> <ul> <li>Configuration files parsed on retries</li> <li>Message queue deduplication (same message reprocessed)</li> <li>Request retries with identical payloads</li> <li>Test fixtures parsed multiple times</li> <li>Any scenario with repeated identical input</li> </ul> <p>Not ideal for:</p> <ul> <li>Unique API requests (every request is different)</li> <li>Streaming data</li> <li>Low-repetition scenarios (cache overhead &gt; benefit)</li> </ul>"},{"location":"guide/caching/#basic-usage","title":"Basic Usage","text":"<pre><code>import \"github.com/vnykmshr/gopantic/pkg/model\"\n\n// Create a cached parser with default config\nparser := model.NewCachedParser[User](nil)\ndefer parser.Close()  // Important: stops background cleanup goroutine\n\n// Parse data - first call is a cache miss\nuser1, err := parser.Parse(jsonData)\n\n// Same data - cache hit (instant return)\nuser2, err := parser.Parse(jsonData)\n</code></pre>"},{"location":"guide/caching/#configuration","title":"Configuration","text":"<pre><code>config := &amp;model.CacheConfig{\n    TTL:             time.Hour,        // How long entries stay valid\n    MaxEntries:      1000,             // Maximum cached entries\n    CleanupInterval: 30 * time.Minute, // Background cleanup frequency\n}\n\nparser := model.NewCachedParser[User](config)\ndefer parser.Close()\n</code></pre>"},{"location":"guide/caching/#configuration-options","title":"Configuration Options","text":"Option Default Description <code>TTL</code> 1 hour Time-to-live for cached entries <code>MaxEntries</code> 1000 Maximum number of cached entries <code>CleanupInterval</code> 30 minutes Background cleanup frequency (0 to disable)"},{"location":"guide/caching/#default-configuration","title":"Default Configuration","text":"<pre><code>config := model.DefaultCacheConfig()\n// TTL: 1 hour\n// MaxEntries: 1000\n// CleanupInterval: 30 minutes\n</code></pre>"},{"location":"guide/caching/#eviction-behavior","title":"Eviction Behavior","text":"<p>The cache uses FIFO eviction (First In, First Out):</p> <ul> <li>When <code>MaxEntries</code> is reached, the oldest entry is evicted</li> <li>Recently accessed entries are NOT prioritized (this is not LRU)</li> <li>Expired entries are removed on access or by background cleanup</li> </ul>"},{"location":"guide/caching/#cache-stats","title":"Cache Stats","text":"<p>Monitor cache performance:</p> <pre><code>size, maxSize, hitRate := parser.Stats()\nfmt.Printf(\"Cache: %d/%d entries, %.1f%% hit rate\\n\",\n    size, maxSize, hitRate*100)\n</code></pre> <ul> <li><code>size</code>: Current number of cached entries</li> <li><code>maxSize</code>: Maximum entries (from config)</li> <li><code>hitRate</code>: Hits / (Hits + Misses), 0.0 to 1.0</li> </ul>"},{"location":"guide/caching/#cache-operations","title":"Cache Operations","text":"<pre><code>// Clear all cached entries\nparser.ClearCache()\n\n// Parse with explicit format\nuser, err := parser.ParseWithFormat(data, model.FormatJSON)\n\n// Stop background cleanup (call when done)\nparser.Close()\n</code></pre>"},{"location":"guide/caching/#thread-safety","title":"Thread Safety","text":"<p><code>CachedParser</code> is fully thread-safe:</p> <ul> <li>Multiple goroutines can call <code>Parse()</code> concurrently</li> <li><code>ClearCache()</code> and <code>Stats()</code> are also safe</li> <li>Internal synchronization uses <code>sync.RWMutex</code></li> </ul> <pre><code>parser := model.NewCachedParser[User](nil)\ndefer parser.Close()\n\nvar wg sync.WaitGroup\nfor i := 0; i &lt; 100; i++ {\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        _, _ = parser.Parse(data)\n    }()\n}\nwg.Wait()\n</code></pre>"},{"location":"guide/caching/#performance-characteristics","title":"Performance Characteristics","text":"Operation First Call Cached Call Simple JSON ~8-10 \u00b5s ~1-2 \u00b5s Complex JSON ~25-30 \u00b5s ~2-3 \u00b5s With validation +2-5 \u00b5s (same as cached) <p>Note: Actual performance depends on struct complexity, validation rules, and input size. Run your own benchmarks for accurate numbers.</p>"},{"location":"guide/caching/#cache-key-generation","title":"Cache Key Generation","text":"<p>Cache keys are generated from:</p> <ol> <li>Content hash: FNV-1a for small inputs (&lt;1KB), SHA256 for larger</li> <li>Type name: Different types don't share cache entries</li> <li>Format: Same data parsed as JSON vs YAML has different keys</li> </ol> <pre><code>// These create separate cache entries:\nparserA := model.NewCachedParser[TypeA](nil)\nparserB := model.NewCachedParser[TypeB](nil)\n\nparserA.Parse(data)  // Key: hash:TypeA:json\nparserB.Parse(data)  // Key: hash:TypeB:json\n</code></pre>"},{"location":"guide/caching/#best-practices","title":"Best Practices","text":"<ol> <li>Always call Close(): Use <code>defer parser.Close()</code> to stop cleanup goroutine</li> <li>Reuse parsers: Create once, use many times (parsers are thread-safe)</li> <li>Size appropriately: Set <code>MaxEntries</code> based on expected unique inputs</li> <li>Monitor hit rate: Low hit rates indicate caching isn't helping</li> <li>Consider TTL: Longer TTL = more hits, but potentially stale data</li> </ol>"},{"location":"guide/caching/#example-api-handler","title":"Example: API Handler","text":"<pre><code>var userParser = model.NewCachedParser[User](nil)\n\nfunc HandleCreateUser(w http.ResponseWriter, r *http.Request) {\n    body, _ := io.ReadAll(r.Body)\n\n    user, err := userParser.Parse(body)\n    if err != nil {\n        http.Error(w, \"Invalid user data\", 400)\n        return\n    }\n\n    // Use user...\n}\n</code></pre>"},{"location":"guide/caching/#example-config-loading-with-retries","title":"Example: Config Loading with Retries","text":"<pre><code>func LoadConfig(path string) (*Config, error) {\n    parser := model.NewCachedParser[Config](&amp;model.CacheConfig{\n        TTL:        5 * time.Minute,\n        MaxEntries: 10,\n    })\n    defer parser.Close()\n\n    var lastErr error\n    for i := 0; i &lt; 3; i++ {\n        data, err := os.ReadFile(path)\n        if err != nil {\n            lastErr = err\n            time.Sleep(time.Second)\n            continue\n        }\n\n        // On retry with same file content, this is a cache hit\n        return parser.Parse(data)\n    }\n\n    return nil, fmt.Errorf(\"failed after 3 retries: %w\", lastErr)\n}\n</code></pre>"},{"location":"guide/validation/","title":"Validation Guide","text":""},{"location":"guide/validation/#basic-syntax","title":"Basic Syntax","text":"<p>Use the <code>validate</code> struct tag:</p> <pre><code>type User struct {\n    Name  string `json:\"name\" validate:\"required,min=2,max=50\"`\n    Email string `json:\"email\" validate:\"required,email\"`\n}\n</code></pre> <p>Multiple validators are comma-separated. Validators are applied in order.</p>"},{"location":"guide/validation/#built-in-validators","title":"Built-in Validators","text":"<p>gopantic includes these built-in validators:</p>"},{"location":"guide/validation/#presence","title":"Presence","text":"Validator Description Example <code>required</code> Field must be non-zero value <code>validate:\"required\"</code> <pre><code>Name string `json:\"name\" validate:\"required\"`\n// \"\" fails, \"Alice\" passes\n</code></pre>"},{"location":"guide/validation/#range","title":"Range","text":"Validator Description Example <code>min</code> Minimum value/length <code>validate:\"min=5\"</code> <code>max</code> Maximum value/length <code>validate:\"max=100\"</code> <code>length</code> Exact length (strings only) <code>validate:\"length=10\"</code> <p>For strings, <code>min</code>/<code>max</code> check length. For numbers, they check value.</p> <pre><code>Age     int    `json:\"age\" validate:\"min=0,max=150\"`      // 0 &lt;= age &lt;= 150\nName    string `json:\"name\" validate:\"min=2,max=50\"`      // 2 &lt;= len(name) &lt;= 50\nCode    string `json:\"code\" validate:\"length=6\"`          // len(code) == 6\n</code></pre>"},{"location":"guide/validation/#string-formats","title":"String Formats","text":"Validator Description Example <code>email</code> Valid email format <code>validate:\"email\"</code> <code>alpha</code> Letters only (a-zA-Z) <code>validate:\"alpha\"</code> <code>alphanum</code> Letters and numbers only <code>validate:\"alphanum\"</code> <pre><code>Email   string `json:\"email\" validate:\"required,email\"`\nCountry string `json:\"country\" validate:\"alpha\"`\nCode    string `json:\"code\" validate:\"alphanum\"`\n</code></pre>"},{"location":"guide/validation/#nested-struct-validation","title":"Nested Struct Validation","text":"<p>Nested structs are validated automatically:</p> <pre><code>type Address struct {\n    Street  string `json:\"street\" validate:\"required\"`\n    City    string `json:\"city\" validate:\"required\"`\n    ZipCode string `json:\"zip_code\" validate:\"required,alphanum\"`\n}\n\ntype User struct {\n    Name    string  `json:\"name\" validate:\"required\"`\n    Address Address `json:\"address\"`  // Nested struct is validated\n}\n</code></pre>"},{"location":"guide/validation/#slice-validation","title":"Slice Validation","text":"<p>Slices can be validated for length:</p> <pre><code>Tags []string `json:\"tags\" validate:\"min=1,max=5\"`  // 1-5 items\n</code></pre>"},{"location":"guide/validation/#custom-validators","title":"Custom Validators","text":"<p>Register custom validation functions for domain-specific rules:</p> <pre><code>model.RegisterGlobalFunc(\"is_even\", func(fieldName string, value interface{}, params map[string]interface{}) error {\n    num, ok := value.(int)\n    if !ok {\n        return nil // Let type validation handle this\n    }\n    if num%2 != 0 {\n        return model.NewValidationError(fieldName, value, \"is_even\", \"must be an even number\")\n    }\n    return nil\n})\n\ntype Numbers struct {\n    EvenNumber int `json:\"even_number\" validate:\"required,is_even\"`\n}\n</code></pre>"},{"location":"guide/validation/#custom-cross-field-validators","title":"Custom Cross-Field Validators","text":"<p>For validations that compare fields against each other:</p> <pre><code>model.RegisterGlobalCrossFieldFunc(\"password_match\", func(fieldName string, fieldValue interface{}, structValue reflect.Value, params map[string]interface{}) error {\n    confirmPassword, ok := fieldValue.(string)\n    if !ok {\n        return model.NewValidationError(fieldName, fieldValue, \"password_match\", \"must be a string\")\n    }\n\n    password := structValue.FieldByName(\"Password\").String()\n    if confirmPassword != password {\n        return model.NewValidationError(fieldName, fieldValue, \"password_match\", \"passwords do not match\")\n    }\n    return nil\n})\n\ntype Registration struct {\n    Password        string `json:\"password\" validate:\"required,min=8\"`\n    ConfirmPassword string `json:\"confirm_password\" validate:\"required,password_match\"`\n}\n</code></pre>"},{"location":"guide/validation/#validation-errors","title":"Validation Errors","text":"<p>Errors include field names and failure reasons:</p> <pre><code>user, err := model.ParseInto[User](data)\nif err != nil {\n    // \"validation error on field 'email': invalid email format\"\n    // \"validation error on field 'age': value 5 is less than minimum 18\"\n}\n</code></pre>"},{"location":"guide/validation/#error-types","title":"Error Types","text":"<pre><code>// Check for specific error types\nvar parseErr *model.ParseError\nif errors.As(err, &amp;parseErr) {\n    // JSON/YAML parsing failed\n}\n\nvar validErr *model.ValidationError\nif errors.As(err, &amp;validErr) {\n    // Validation rule failed\n}\n</code></pre>"},{"location":"guide/validation/#sensitive-field-protection","title":"Sensitive Field Protection","text":"<p>Sensitive field values are automatically redacted in error output:</p> <pre><code>type Login struct {\n    Username string `json:\"username\" validate:\"required\"`\n    Password string `json:\"password\" validate:\"required,min=8\"`\n}\n\n// If password validation fails, the error won't contain the actual password\n// The value will show as \"[REDACTED]\" in error reports\n</code></pre>"},{"location":"guide/validation/#tips","title":"Tips","text":"<ol> <li>Order matters: <code>validate:\"required,email\"</code> checks required first</li> <li>Empty strings: An empty string passes <code>min=0</code> but fails <code>required</code></li> <li>Nil slices: A nil slice fails <code>required</code> but passes <code>min=0</code></li> <li>Performance: Validation metadata is cached per type</li> </ol>"},{"location":"guide/validation/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/validation/#password-with-confirmation","title":"Password with Confirmation","text":"<pre><code>// Register a custom cross-field validator\nmodel.RegisterGlobalCrossFieldFunc(\"eqfield\", func(fieldName string, fieldValue interface{}, structValue reflect.Value, params map[string]interface{}) error {\n    otherField := params[\"value\"].(string)\n    otherValue := structValue.FieldByName(otherField)\n    if !otherValue.IsValid() {\n        return model.NewValidationError(fieldName, fieldValue, \"eqfield\", \"comparison field not found\")\n    }\n    if fieldValue != otherValue.Interface() {\n        return model.NewValidationError(fieldName, fieldValue, \"eqfield\", \"fields do not match\")\n    }\n    return nil\n})\n\ntype Registration struct {\n    Password        string `json:\"password\" validate:\"required,min=8\"`\n    ConfirmPassword string `json:\"confirm_password\" validate:\"required,eqfield=Password\"`\n}\n</code></pre>"},{"location":"guide/validation/#optional-with-format","title":"Optional with Format","text":"<pre><code>// Use custom validator for optional + format\nmodel.RegisterGlobalFunc(\"optional_email\", func(fieldName string, value interface{}, params map[string]interface{}) error {\n    str, ok := value.(string)\n    if !ok || str == \"\" {\n        return nil // Empty is OK\n    }\n    // Validate email format if non-empty\n    if !strings.Contains(str, \"@\") {\n        return model.NewValidationError(fieldName, value, \"optional_email\", \"invalid email format\")\n    }\n    return nil\n})\n\nEmail string `json:\"email\" validate:\"optional_email\"`\n</code></pre>"},{"location":"guide/validation/#phone-number","title":"Phone Number","text":"<pre><code>Phone string `json:\"phone\" validate:\"required,alphanum,min=10,max=15\"`\n</code></pre>"},{"location":"guide/validation/#extending-validators","title":"Extending Validators","text":"<p>For validators not included by default (like <code>url</code>, <code>uuid</code>, <code>oneof</code>), register custom implementations:</p> <pre><code>// Example: oneof validator\nmodel.RegisterGlobalFunc(\"oneof\", func(fieldName string, value interface{}, params map[string]interface{}) error {\n    str, ok := value.(string)\n    if !ok {\n        return nil\n    }\n    allowed := strings.Split(params[\"value\"].(string), \" \")\n    for _, v := range allowed {\n        if str == v {\n            return nil\n        }\n    }\n    return model.NewValidationError(fieldName, value, \"oneof\",\n        fmt.Sprintf(\"must be one of: %s\", strings.Join(allowed, \", \")))\n})\n\nStatus string `json:\"status\" validate:\"oneof=draft published archived\"`\n</code></pre>"},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#core-functions","title":"Core Functions","text":""},{"location":"reference/api/#parseinto","title":"ParseInto","text":"<pre><code>func ParseInto[T any](data []byte) (T, error)\n</code></pre> <p>Parses JSON or YAML with automatic format detection, type coercion, and validation.</p> <pre><code>user, err := model.ParseInto[User]([]byte(`{\"id\": 1, \"name\": \"Alice\"}`))\n</code></pre>"},{"location":"reference/api/#parseintowithformat","title":"ParseIntoWithFormat","text":"<pre><code>func ParseIntoWithFormat[T any](data []byte, format Format) (T, error)\n</code></pre> <p>Parses with explicit format (<code>FormatJSON</code> or <code>FormatYAML</code>).</p> <pre><code>user, err := model.ParseIntoWithFormat[User](yamlData, model.FormatYAML)\n</code></pre>"},{"location":"reference/api/#validate","title":"Validate","text":"<pre><code>func Validate[T any](v *T) error\n</code></pre> <p>Validates an already-parsed struct.</p> <pre><code>var user User\njson.Unmarshal(data, &amp;user)\nerr := model.Validate(&amp;user)\n</code></pre>"},{"location":"reference/api/#format-detection","title":"Format Detection","text":""},{"location":"reference/api/#detectformat","title":"DetectFormat","text":"<pre><code>func DetectFormat(data []byte) Format\n</code></pre> <p>Auto-detects JSON or YAML format. Looks for JSON markers (<code>{</code>, <code>[</code>), YAML markers (<code>---</code>, <code>:</code>), defaults to JSON for ambiguous cases.</p>"},{"location":"reference/api/#caching","title":"Caching","text":""},{"location":"reference/api/#newcachedparser","title":"NewCachedParser","text":"<pre><code>func NewCachedParser[T any](config *CacheConfig) *CachedParser[T]\n</code></pre> <p>Creates a cached parser instance.</p> <pre><code>config := &amp;model.CacheConfig{\n    TTL:             5 * time.Minute,\n    MaxEntries:      1000,\n    CleanupInterval: 2 * time.Minute,\n}\nparser := model.NewCachedParser[User](config)\ndefer parser.Close()\n</code></pre>"},{"location":"reference/api/#cachedparser-methods","title":"CachedParser Methods","text":"<pre><code>func (cp *CachedParser[T]) Parse(data []byte) (T, error)\nfunc (cp *CachedParser[T]) ParseWithFormat(data []byte, format Format) (T, error)\nfunc (cp *CachedParser[T]) Stats() (size, maxSize int, hitRate float64)\nfunc (cp *CachedParser[T]) ClearCache()\nfunc (cp *CachedParser[T]) Close()\n</code></pre>"},{"location":"reference/api/#defaultcacheconfig","title":"DefaultCacheConfig","text":"<pre><code>func DefaultCacheConfig() *CacheConfig\n</code></pre> <p>Returns sensible defaults:</p> <ul> <li>TTL: 1 hour</li> <li>MaxEntries: 1000</li> <li>CleanupInterval: 30 minutes</li> </ul>"},{"location":"reference/api/#configuration","title":"Configuration","text":""},{"location":"reference/api/#cacheconfig","title":"CacheConfig","text":"<pre><code>type CacheConfig struct {\n    TTL             time.Duration // Time to live for cached entries (default: 1 hour)\n    MaxEntries      int           // Maximum number of cached entries (default: 1000)\n    CleanupInterval time.Duration // How often to run cleanup (default: TTL/2, 0 to disable)\n}\n</code></pre>"},{"location":"reference/api/#global-configuration","title":"Global Configuration","text":"<p>Package-level configuration variables:</p> <pre><code>var MaxInputSize = 10 * 1024 * 1024  // Max 10MB input (0 = unlimited)\nvar MaxCacheSize = 1000               // Max validation metadata cache (0 = unlimited)\nvar MaxValidationDepth = 32           // Max nested struct depth\nvar MaxStructureDepth = 64            // Max JSON/YAML nesting depth (0 = unlimited)\n</code></pre> <p>Warning: Direct modification of these variables is NOT thread-safe. Use the Get/Set functions for concurrent access.</p>"},{"location":"reference/api/#thread-safe-accessors","title":"Thread-Safe Accessors","text":"<pre><code>// MaxInputSize\nfunc GetMaxInputSize() int\nfunc SetMaxInputSize(size int)\n\n// MaxCacheSize\nfunc GetMaxCacheSize() int\nfunc SetMaxCacheSize(size int)\n\n// MaxValidationDepth\nfunc GetMaxValidationDepth() int\nfunc SetMaxValidationDepth(depth int)\n\n// MaxStructureDepth\nfunc GetMaxStructureDepth() int\nfunc SetMaxStructureDepth(depth int)\n</code></pre> <p>Example:</p> <pre><code>// Safe for concurrent use\nmodel.SetMaxInputSize(5 * 1024 * 1024)  // 5MB\nsize := model.GetMaxInputSize()\n</code></pre>"},{"location":"reference/api/#sensitive-field-patterns","title":"Sensitive Field Patterns","text":"<p>Configure which field names are considered sensitive for error value sanitization:</p> <pre><code>// Get current patterns\npatterns := model.GetSensitiveFieldPatterns()\n\n// Replace all patterns\nmodel.SetSensitiveFieldPatterns([]string{\"password\", \"secret\", \"token\"})\n\n// Add a pattern\nmodel.AddSensitiveFieldPattern(\"ssn\")\n\n// Check if a field is sensitive\nmodel.IsSensitiveField(\"user_password\")  // true\n</code></pre> <p>Default patterns: <code>password</code>, <code>passwd</code>, <code>secret</code>, <code>token</code>, <code>key</code>, <code>credential</code>, <code>auth</code>, <code>api_key</code>, <code>apikey</code>, <code>private</code>, <code>bearer</code></p>"},{"location":"reference/api/#validation-tags","title":"Validation Tags","text":""},{"location":"reference/api/#built-in-validators","title":"Built-in Validators","text":"Tag Applies To Description Example <code>required</code> All types Non-zero value required <code>validate:\"required\"</code> <code>min=N</code> Numbers Minimum value <code>validate:\"min=1\"</code> <code>max=N</code> Numbers Maximum value <code>validate:\"max=100\"</code> <code>min=N</code> String, Slice Minimum length <code>validate:\"min=3\"</code> <code>max=N</code> String, Slice Maximum length <code>validate:\"max=50\"</code> <code>length=N</code> String Exact length <code>validate:\"length=8\"</code> <code>email</code> String Valid email format <code>validate:\"email\"</code> <code>alpha</code> String Alphabetic only (a-zA-Z) <code>validate:\"alpha\"</code> <code>alphanum</code> String Alphanumeric only <code>validate:\"alphanum\"</code>"},{"location":"reference/api/#custom-validators","title":"Custom Validators","text":"<p>Cross-field validators (like <code>eqfield</code>, <code>nefield</code>) are not built-in but can be easily added:</p> <pre><code>model.RegisterGlobalFunc(\"is_even\", func(fieldName string, value interface{}, params map[string]interface{}) error {\n    num, ok := value.(int)\n    if !ok {\n        return nil\n    }\n    if num%2 != 0 {\n        return model.NewValidationError(fieldName, value, \"is_even\", \"must be even\")\n    }\n    return nil\n})\n</code></pre>"},{"location":"reference/api/#type-coercion","title":"Type Coercion","text":"<p>Automatic conversion between compatible types:</p> Target From Examples <code>int</code> <code>string</code>, <code>float64</code> <code>\"42\"</code> \u2192 <code>42</code>, <code>42.0</code> \u2192 <code>42</code> <code>float64</code> <code>string</code>, <code>int</code> <code>\"3.14\"</code> \u2192 <code>3.14</code>, <code>42</code> \u2192 <code>42.0</code> <code>bool</code> <code>string</code>, <code>int</code> <code>\"true\"</code> \u2192 <code>true</code>, <code>1</code> \u2192 <code>true</code> <code>string</code> Any <code>42</code> \u2192 <code>\"42\"</code>, <code>true</code> \u2192 <code>\"true\"</code> <code>time.Time</code> <code>string</code>, <code>int</code> RFC3339, Unix timestamps <p>Boolean coercion:</p> <ul> <li>Truthy: <code>\"true\"</code>, <code>\"yes\"</code>, <code>\"1\"</code>, <code>\"on\"</code>, <code>1</code>, non-zero</li> <li>Falsy: <code>\"false\"</code>, <code>\"no\"</code>, <code>\"0\"</code>, <code>\"off\"</code>, <code>\"\"</code>, <code>0</code></li> </ul> <p>Time formats: RFC3339, RFC3339Nano, Date only (<code>2023-01-15</code>), Unix timestamp (int/float)</p>"},{"location":"reference/api/#error-types","title":"Error Types","text":""},{"location":"reference/api/#parseerror","title":"ParseError","text":"<pre><code>type ParseError struct {\n    Field   string\n    Value   interface{}\n    Type    string\n    Message string\n}\n</code></pre> <p>Returned for type coercion failures.</p>"},{"location":"reference/api/#validationerror","title":"ValidationError","text":"<pre><code>type ValidationError struct {\n    Field   string\n    Value   interface{}\n    Rule    string\n    Message string\n}\n</code></pre> <p>Returned for validation failures.</p>"},{"location":"reference/api/#multiple-errors","title":"Multiple Errors","text":"<p>Multiple errors are aggregated:</p> <pre><code>multiple errors: validation error on field 'ID': field is required; parse error on field 'Age': cannot convert string 'invalid' to integer\n</code></pre> <p>Security note: Error messages include field values. Sanitize before logging or returning to clients.</p>"},{"location":"reference/api/#struct-tags","title":"Struct Tags","text":""},{"location":"reference/api/#json-tags","title":"JSON Tags","text":"<pre><code>type User struct {\n    ID     int    `json:\"id\"`\n    Name   string `json:\"name,omitempty\"`\n    Hidden string `json:\"-\"`  // Ignored\n}\n</code></pre>"},{"location":"reference/api/#yaml-tags","title":"YAML Tags","text":"<pre><code>type Config struct {\n    Port int    `yaml:\"port\" json:\"port\"`  // Both formats\n    Host string `yaml:\"host\"`               // YAML only\n}\n</code></pre> <p>Falls back to JSON tag if YAML tag is missing.</p>"},{"location":"reference/api/#see-also","title":"See Also","text":"<ul> <li>Types Reference - Supported types and limitations</li> <li>Migration Guide - Switching from other libraries</li> <li>Architecture - Implementation details</li> </ul>"},{"location":"reference/types/","title":"Type Reference","text":""},{"location":"reference/types/#supported-types","title":"Supported Types","text":"Type Support Coercion Notes Primitives (<code>string</code>, <code>int</code>, <code>float64</code>, <code>bool</code>) Full Yes All validation tags work Slices &amp; Arrays (<code>[]T</code>, <code>[N]T</code>) Full Yes Element validation supported Nested Structs Full Yes Recursive validation Pointers (<code>*T</code>) Full Yes Nil handling for optional fields <code>time.Time</code> Full Yes RFC3339, Unix timestamps <code>json.RawMessage</code> Full Yes Preserves raw JSON Maps (<code>map[string]T</code>) Partial Limited Structure only, no element validation <code>interface{}</code> Partial Yes Runtime detection, limited validation Custom types with <code>UnmarshalJSON</code> Compatible N/A Standard library patterns work"},{"location":"reference/types/#type-coercion","title":"Type Coercion","text":"<p>gopantic automatically converts between compatible types:</p> <pre><code>// String to number\ntype Product struct {\n    Price float64 `json:\"price\"`\n}\n// {\"price\": \"19.99\"} \u2192 Product{Price: 19.99}\n\n// Number to string\ntype Request struct {\n    ID string `json:\"id\"`\n}\n// {\"id\": 12345} \u2192 Request{ID: \"12345\"}\n\n// String to boolean\n// \"true\", \"false\", \"1\", \"0\" all work\n\n// Unix timestamp to time.Time\n// 1704067200 \u2192 parsed time.Time\n</code></pre> <p>Performance: Coercion adds ~5-10% overhead. If input is already correctly typed:</p> <pre><code>var req Request\njson.Unmarshal(body, &amp;req)  // No coercion\nmodel.Validate(&amp;req)         // Just validation\n</code></pre>"},{"location":"reference/types/#jsonrawmessage","title":"json.RawMessage","text":"<p>Preserve raw JSON for flexible metadata or deferred parsing:</p> <pre><code>type Account struct {\n    ID          string          `json:\"id\" validate:\"required\"`\n    MetadataRaw json.RawMessage `json:\"metadata,omitempty\"`\n}\n\n// Parse with validation\naccount, err := model.ParseInto[Account](input)\n\n// Later: parse metadata as needed\nvar metadata map[string]interface{}\njson.Unmarshal(account.MetadataRaw, &amp;metadata)\n</code></pre> <p>Common use cases:</p> <ul> <li>PostgreSQL JSONB columns</li> <li>Plugin/extension systems</li> <li>Multi-tenant configurations</li> <li>Event payloads with varying schemas</li> </ul>"},{"location":"reference/types/#nested-structs","title":"Nested Structs","text":"<p>Recursive validation works automatically:</p> <pre><code>type Address struct {\n    City    string `json:\"city\" validate:\"required\"`\n    ZipCode string `json:\"zip_code\" validate:\"len=5\"`\n}\n\ntype User struct {\n    Name    string  `json:\"name\" validate:\"required\"`\n    Address Address `json:\"address\" validate:\"required\"`\n}\n\n// Both User and Address are validated\nuser, err := model.ParseInto[User](input)\n</code></pre> <p>Optional nested structs:</p> <pre><code>type User struct {\n    Name    string   `json:\"name\" validate:\"required\"`\n    Address *Address `json:\"address,omitempty\"`  // Optional\n}\n</code></pre>"},{"location":"reference/types/#slices-and-arrays","title":"Slices and Arrays","text":"<pre><code>type UserList struct {\n    Users []User `json:\"users\" validate:\"required,min=1\"`\n}\n\n// Each User element is validated\n</code></pre> <p>Primitive slices work too:</p> <pre><code>type Tags struct {\n    Items []string `json:\"items\" validate:\"min=1\"`\n}\n</code></pre>"},{"location":"reference/types/#pointers-optional-fields","title":"Pointers (Optional Fields)","text":"<p>Use pointers to distinguish missing from zero values:</p> <pre><code>type UpdateRequest struct {\n    Name  *string `json:\"name,omitempty\"`   // nil = not provided\n    Age   *int    `json:\"age,omitempty\"`    // 0 vs nil\n    Email *string `json:\"email,omitempty\" validate:\"email\"`\n}\n\n// {\"name\": \"Alice\"} \u2192 Name=\"Alice\", Age=nil, Email=nil\n</code></pre>"},{"location":"reference/types/#custom-types","title":"Custom Types","text":"<p>Implement <code>UnmarshalJSON</code> for custom parsing:</p> <pre><code>type CustomID string\n\nfunc (c *CustomID) UnmarshalJSON(data []byte) error {\n    var s string\n    if err := json.Unmarshal(data, &amp;s); err != nil {\n        return err\n    }\n    if !strings.HasPrefix(s, \"id_\") {\n        return errors.New(\"invalid ID format\")\n    }\n    *c = CustomID(s)\n    return nil\n}\n\ntype Request struct {\n    ID CustomID `json:\"id\" validate:\"required\"`\n}\n</code></pre>"},{"location":"reference/types/#time-handling","title":"Time Handling","text":"<p>Automatic support for:</p> <ul> <li>RFC3339: <code>\"2024-01-01T12:00:00Z\"</code></li> <li>Unix timestamps: <code>1704067200</code></li> <li>ISO 8601: <code>\"2024-01-01T12:00:00+00:00\"</code></li> </ul> <p>For custom formats, implement <code>UnmarshalJSON</code>:</p> <pre><code>type CustomTime time.Time\n\nfunc (ct *CustomTime) UnmarshalJSON(data []byte) error {\n    var s string\n    json.Unmarshal(data, &amp;s)\n    t, err := time.Parse(\"2006-01-02\", s)\n    if err != nil {\n        return err\n    }\n    *ct = CustomTime(t)\n    return nil\n}\n</code></pre>"},{"location":"reference/types/#limitations-and-workarounds","title":"Limitations and Workarounds","text":""},{"location":"reference/types/#maps-limited-validation","title":"Maps (Limited Validation)","text":"<p>Problem: Can't validate individual map values</p> <pre><code>type Config struct {\n    Settings map[string]string `json:\"settings\" validate:\"required\"`\n    // Only validates existence/length, not individual values\n}\n</code></pre> <p>Workaround: Use <code>json.RawMessage</code> + manual validation</p> <pre><code>type Config struct {\n    SettingsRaw json.RawMessage `json:\"settings,omitempty\"`\n}\n\nfunc (c *Config) ValidateSettings() error {\n    var settings map[string]string\n    json.Unmarshal(c.SettingsRaw, &amp;settings)\n\n    for key, value := range settings {\n        if len(value) &lt; 3 {\n            return fmt.Errorf(\"setting %s: value too short\", key)\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"reference/types/#interface-limited-validation","title":"interface{} (Limited Validation)","text":"<p>Problem: Can't validate beyond type checking</p> <pre><code>type Flexible struct {\n    Data interface{} `json:\"data\" validate:\"required\"`\n    // \"required\" works, but no deep validation\n}\n</code></pre> <p>Workaround: Type assertions</p> <pre><code>func (f *Flexible) ValidateData() error {\n    switch v := f.Data.(type) {\n    case string:\n        if len(v) &lt; 3 {\n            return errors.New(\"string too short\")\n        }\n    case map[string]interface{}:\n        if len(v) == 0 {\n            return errors.New(\"map empty\")\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"reference/types/#circular-references","title":"Circular References","text":"<p>Problem: Causes infinite loops</p> <pre><code>type Node struct {\n    Children []Node `json:\"children\"` // OK\n    Parent   *Node  `json:\"parent\"`   // Circular!\n}\n</code></pre> <p>Workaround: Use IDs</p> <pre><code>type Node struct {\n    ID       string `json:\"id\"`\n    ParentID string `json:\"parent_id,omitempty\"`\n    Children []Node `json:\"children\"`\n}\n</code></pre>"},{"location":"reference/types/#non-string-map-keys","title":"Non-String Map Keys","text":"<p>Problem: JSON limitation</p> <pre><code>type Data struct {\n    Counts map[int]string `json:\"counts\"`\n    // Keys serialized as strings: {\"1\": \"one\"}\n}\n</code></pre> <p>Workaround: Use string keys or implement <code>UnmarshalJSON</code></p> <pre><code>type Data struct {\n    Counts map[string]string `json:\"counts\"`\n}\n</code></pre>"},{"location":"reference/types/#functionchannel-fields","title":"Function/Channel Fields","text":"<p>Must be skipped:</p> <pre><code>type Valid struct {\n    Handler func()   `json:\"-\"`\n    Ch      chan int `json:\"-\"`\n    Name    string   `json:\"name\"`\n}\n</code></pre>"},{"location":"reference/types/#edge-cases","title":"Edge Cases","text":""},{"location":"reference/types/#zero-values-vs-missing-fields","title":"Zero Values vs Missing Fields","text":"<p>JSON can't distinguish:</p> <pre><code>// {} and {\"count\": 0} both result in Count: 0\ntype Request struct {\n    Count int `json:\"count\"`\n}\n</code></pre> <p>Use pointers for optional fields:</p> <pre><code>type Request struct {\n    Count *int `json:\"count,omitempty\"`\n}\n// {} \u2192 Count: nil\n// {\"count\": 0} \u2192 Count: &amp;0\n</code></pre>"},{"location":"reference/types/#large-jsonrawmessage","title":"Large json.RawMessage","text":"<p><code>json.RawMessage</code> keeps entire JSON in memory. For large fields (&gt;1MB), consider:</p> <ul> <li>External storage (S3, database BLOB)</li> <li>Streaming/chunked processing</li> <li>Compression</li> </ul>"},{"location":"reference/types/#array-length-validation","title":"Array Length Validation","text":"<p>Fixed-length array mismatches may not be caught in all cases:</p> <pre><code>type Data struct {\n    Scores [3]float64 `json:\"scores\"`\n}\n// {\"scores\": [1.0]} may not error (known limitation)\n</code></pre> <p>Use slices with length validation:</p> <pre><code>type Data struct {\n    Scores []float64 `json:\"scores\" validate:\"required,len=3\"`\n}\n</code></pre>"},{"location":"reference/types/#performance-tips","title":"Performance Tips","text":"<ol> <li>Skip coercion if types are correct: Use <code>json.Unmarshal</code> + <code>model.Validate()</code></li> <li>Use pointers sparingly: Only for truly optional fields</li> <li>Avoid deep nesting: Flatten structures when possible</li> <li>json.RawMessage for large/dynamic data: More efficient than map[string]interface{}</li> <li>Cache parsed metadata: Don't unmarshal RawMessage repeatedly</li> </ol>"},{"location":"reference/types/#design-philosophy","title":"Design Philosophy","text":"<p>Type Coercion: gopantic prioritizes developer convenience over strict typing. This reduces boilerplate when dealing with APIs that send <code>\"123\"</code> instead of <code>123</code>.</p> <p>Validation Tags: Simple comma-separated syntax for common cases. Use custom validators for complex rules.</p> <p>Compatibility: Works with standard library patterns (<code>UnmarshalJSON</code>, <code>json.RawMessage</code>) rather than replacing them.</p>"},{"location":"reference/types/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Migration Guide - Switching from other libraries</li> <li>Architecture - Implementation details</li> </ul>"}]}